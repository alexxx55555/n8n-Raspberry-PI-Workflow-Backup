{
  "createdAt": "2025-09-02T14:14:42.893Z",
  "updatedAt": "2025-09-30T08:57:41.000Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Slack Summary",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -67072,
        -22224
      ],
      "id": "40e6849b-6546-4357-8efe-a52e415168f6",
      "name": "Send a message",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  const event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.subtype === 'bot_message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 4) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 5) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 6) IMPROVED URL EXTRACTION - Works with mobile\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text (mobile often sends encoded URLs)\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Pattern 1: Slack format <http://example.com|label> or <http://example.com>\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  // Pattern 2: URL-encoded Slack format (mobile)\n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  // Pattern 3: Plain URLs\n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  // Pattern 4: Fully encoded URLs\n  const encodedUrlRegex = /https?%3A%2F%2F[^\\s<>\"'()[\\]{}]+/gi;\n  while ((match = encodedUrlRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[0]));\n    } catch (e) {\n      urls.add(match[0]);\n    }\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  return {\n    json: {\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user,\n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -69344,
        -22544
      ],
      "id": "d0ea7ac4-1635-4c44-9cc4-584c19a2de28",
      "name": "Extract Slack URL",
      "executeOnce": false,
      "disabled": true
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -68480,
        -22560
      ],
      "id": "33337fef-da3c-4e18-a909-8cf008d8fa6d",
      "name": "Respond to Webhook",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -69008,
        -22544
      ],
      "id": "21b6f324-5afa-4aba-ad6a-77ec10d66718",
      "name": "If",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -68736,
        -22560
      ],
      "id": "68dfb7b4-b700-4c8a-90c6-fa822286d608",
      "name": "Return Slack Challenge",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Log input for debugging\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html) {\n  console.log(\"No HTML content found\");\n  return { error: \"No HTML content found\", availableFields: Object.keys(inputData) };\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- Step 1: Try JSON-LD structured data FIRST (best for mobile sites) ---\ntry {\n  const jsonBlocks = html.match(/<script[^>]+type=[\"']application\\/(ld\\+json|json)[\"'][^>]*>([\\s\\S]*?)<\\/script>/gi);\n  if (jsonBlocks) {\n    for (let block of jsonBlocks) {\n      try {\n        const clean = block.replace(/<script[^>]*>/i, \"\").replace(/<\\/script>/i, \"\").trim();\n        const parsed = JSON.parse(clean);\n        \n        // Recursive search for article content\n        function findContent(obj) {\n          if (!obj || typeof obj !== \"object\") return null;\n          if (obj.articleBody && typeof obj.articleBody === \"string\" && obj.articleBody.length > 200) return obj.articleBody;\n          if (obj.text && typeof obj.text === \"string\" && obj.text.length > 200) return obj.text;\n          if (obj.description && typeof obj.description === \"string\" && obj.description.length > 200) return obj.description;\n          \n          for (const key of Object.keys(obj)) {\n            const result = findContent(obj[key]);\n            if (result) return result;\n          }\n          return null;\n        }\n        \n        const result = findContent(parsed);\n        if (result && result.length > 200) {\n          text = result;\n          console.log(\"Found content in JSON-LD\");\n          break;\n        }\n      } catch (err) {\n        console.log(\"JSON parse error:\", err.message);\n      }\n    }\n  }\n} catch (e) {\n  console.log(\"JSON extraction error:\", e.message);\n}\n\n// --- Step 2: Try <article> tag ---\nif (text.length < 200) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      console.log(\"Found content in <article>\");\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 3: Try <p> and heading tags ---\nif (text.length < 200) {\n  console.log(\"Trying <p> and heading tags\");\n  try {\n    const matches = html.match(/<(p|h[1-6])[^>]*>(.*?)<\\/(p|h[1-6])>/gis);\n    if (matches) {\n      text = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => t.length > 20 && !t.match(/\\{|\\}/))  // Filter out CSS/JS\n        .join(\"\\n\\n\");\n      console.log(\"Found content in paragraphs\");\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 4: Check if we got CSS/JS instead of content ---\nconst cssJsIndicators = /\\{[\\s\\S]*?\\}|function\\s*\\(|\\.css|@media|var\\(--/;\nif (cssJsIndicators.test(text)) {\n  console.log(\"Detected CSS/JS code instead of article content\");\n  return { \n    error: \"Mobile site - unable to extract article content (got CSS/JS instead)\", \n    url: inputData.url || \"unknown\"\n  };\n}\n\n// --- Final validation ---\nif (!text || text.length < 200) {\n  console.log(\"Article body not found\");\n  return { \n    error: \"Article body not found (likely JS-rendered mobile site)\", \n    url: inputData.url || \"unknown\"\n  };\n}\n\nconsole.log(\"Extracted text length:\", text.length, \"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn { \n  article: text, \n  url: inputData.url || \"\",\n  originalLength: html.length, \n  extractedLength: text.length \n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -69360,
        -22224
      ],
      "id": "fa398ca8-bcb2-4ab5-ac5c-987fa18bd404",
      "name": "HTML Extract",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// === HELPER FUNCTION - AT TOP ===\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => b && b.length > 20); // Filter short/empty bullets\n}\n\n// Log input\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\n// Get language from input\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\n\n// Aggressive cleaning\nlet s = raw\n  .replace(/```json\\s*/gi, \"\")\n  .replace(/```\\s*/g, \"\")\n  .replace(/\\*Automated with.*$/gim, \"\")\n  .replace(/^[^{]*/, \"\")  // Remove before {\n  .replace(/[^}]*$/, \"\")  // Remove after }\n  .replace(/-/g, \"-\")\n  .replace(/[\\r\\n]+/g, \" \")\n  .replace(/[\\u2018\\u2019]/g, \"'\")\n  .replace(/[\\u201C\\u201D]/g, '\"')\n  .replace(/\\s+/g, \" \")\n  .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n}\n\n// Try regex salvage if parse failed\nif (!obj || typeof obj !== \"object\") {\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,  // ✅ PASS LANGUAGE\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language  // ✅ PASS LANGUAGE\n    }\n  }];\n}\n\n// Normal success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\n// Clean bullets\nbullets = cleanBullets(bullets, language);\n\n// Ensure exactly 5 bullets\nif (bullets.length > 5) bullets = bullets.slice(0, 5);\n\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים.\" \n  : \"No further details available.\";\n\nwhile (bullets.length < 5) {\n  bullets.push(defaultBullet);\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,\n    url: $json.url || null,\n    language: language,  // ✅ PASS LANGUAGE\n    source: $json.source || \"Local\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -67792,
        -22224
      ],
      "id": "82f9572e-575b-488e-86af-921c5a4f8825",
      "name": "Validator",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// --- Error case ---\nif (error) {\n  const errorMsg = language === \"he\" ? \"שגיאה בעיבוד המאמר\" : \"Error processing article\";\n  const sourceText = language === \"he\" ? \"מקור:\" : \"Source:\";\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${sourceText} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : \"Unknown\")}`\n    }\n  }];\n}\n\n// --- Clean title ---\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .trim();\n\n// --- Clean bullets ---\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    // Filter out English default bullets if language is Hebrew\n    if (language === \"he\" && b === \"No further details available.\") {\n      return false;\n    }\n    return b && b.length > 25;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")  // Remove existing bullets\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\n// --- Guarantee 5 bullets with language-appropriate defaults ---\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים בנושא זה\" \n  : \"No further details available\";\n\nwhile (cleanBullets.length < 5) {\n  cleanBullets.push(defaultBullet);\n}\n\n// --- Build Slack message ---\nconst RTL = \"\\u200F\";\n\nif (language === \"he\") {\n  const titleLine = url \n    ? `:brain: סיכום: <${url}|${cleanTitle}>` \n    : `:brain: סיכום: ${cleanTitle}`;\n  \n  // Build message with proper RTL wrapping\n  const bulletLines = cleanBullets.map(b => `${RTL}• ${b}${RTL}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -67536,
        -22224
      ],
      "id": "9d9f0861-7c99-4bd4-933f-278b2874e04a",
      "name": "Formatter",
      "disabled": true
    },
    {
      "parameters": {
        "url": "={{$json[\"url\"]}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -69632,
        -22224
      ],
      "id": "9455bb97-07b9-4735-be04-20d086c28215",
      "name": "HTTP Request",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert summarization tool that creates accurate, fact-based summaries.\n\nLanguage: {{$json[\"language\"]}}\n\nCRITICAL: The source text below is in {{$json[\"language\"]}}. You MUST summarize it in the SAME language - do NOT translate.\n- If language is \"he\" → the text is Hebrew, summarize in Hebrew\n- If language is \"en\" → the text is English, summarize in English\n\nTASK: Summarize the text into exactly 5 detailed bullet points IN THE SAME LANGUAGE AS THE SOURCE.\n\nACCURACY RULES:\n- ONLY use information explicitly stated in the source text\n- NEVER invent, assume, or add names, facts, or details not in the source\n- Use names and facts exactly as written in the source\n- Do NOT translate - keep the same language as input\n- Do NOT add context or background not present in the text\n\nBULLET REQUIREMENTS:\n- Each bullet: 3-5 complete sentences (40-60 words)\n- Start each bullet with • (bullet character)\n- Include only specific information from the source\n- Write in clear, journalistic style\n- Every sentence must be complete\n\nOUTPUT RULES:\n- Output ONLY valid JSON\n- NO markdown (no ```), NO extra text\n- Start with { and end with }\n\nRequired format:\n{\"title\":\"Title in same language as source\",\"bullets\":[\"• First detailed bullet in source language.\",\"• Second detailed bullet in source language.\",\"• Third detailed bullet in source language.\",\"• Fourth detailed bullet in source language.\",\"• Fifth detailed bullet in source language.\"]}\n\nText to summarize:\n{{ $json[\"chunk\"] }}\n\nCRITICAL: Write the summary in the SAME language as the text above. Do NOT translate.",
        "needsFallback": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -68592,
        -22224
      ],
      "id": "34ca356c-530a-434d-bc6f-d4fe1f6f1b48",
      "name": "AI Agent",
      "disabled": true
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -69584,
        -22544
      ],
      "id": "3e66a8cf-0cd3-40ee-9779-962d9e8840df",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "console.log(\"Chunker input article length:\", $json.article?.length || 0, \"Sample:\", $json.article?.slice(0, 500));\n\nconst CHUNK_SIZE = 2000;   // smaller than before\nconst OVERLAP = 150;\nconst MAX_CHUNKS = 20;\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ json: { url, chunk: text.slice(i, i + CHUNK_SIZE), index: chunks.length + 1 } });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Sample chunk:\", chunks[0]?.json.chunk.slice(0, 500));\nreturn chunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -69136,
        -22224
      ],
      "id": "5e498db8-fa13-49c3-a2c0-f6311d007068",
      "name": "Chunker",
      "executeOnce": false,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -68080,
        -22224
      ],
      "id": "67f69db1-b9b7-4500-8309-52267a73facb",
      "name": "Debug logger",
      "executeOnce": false,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// LANGUAGE DETECTOR NODE\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",  // Default fallback\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count Hebrew characters\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\n\n// Only treat as Hebrew if at least 20% of characters are Hebrew AND total length > 200\nconst language = (hebrewRatio > 0.2 && totalChars > 200) ? \"he\" : \"en\";\n\nconsole.log(`Language detected: ${language}, Hebrew chars: ${hebrewChars}, Ratio: ${hebrewRatio.toFixed(3)}, Total: ${totalChars}`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -68928,
        -22224
      ],
      "id": "27b1cbdd-524c-4c44-90bd-714cd8d86c38",
      "name": "Language Detector",
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "google/gemma-3-12b",
          "mode": "list",
          "cachedResultName": "google/gemma-3-12b"
        },
        "options": {
          "maxTokens": 1500,
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -68656,
        -21968
      ],
      "id": "879a71c2-d1a5-4fe6-96b3-6513cfc7d39a",
      "name": "AI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -65056,
        -20528
      ],
      "id": "a1ebcb6b-f54d-447b-97b1-3cedb2eebe16",
      "name": "Send a message1",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  const event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.subtype === 'bot_message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 4) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 5) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 6) IMPROVED URL EXTRACTION - Works with mobile\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text (mobile often sends encoded URLs)\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Pattern 1: Slack format <http://example.com|label> or <http://example.com>\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  // Pattern 2: URL-encoded Slack format (mobile)\n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  // Pattern 3: Plain URLs\n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  // Pattern 4: Fully encoded URLs\n  const encodedUrlRegex = /https?%3A%2F%2F[^\\s<>\"'()[\\]{}]+/gi;\n  while ((match = encodedUrlRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[0]));\n    } catch (e) {\n      urls.add(match[0]);\n    }\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  return {\n    json: {\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user,\n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -67328,
        -20848
      ],
      "id": "0714ac49-b8f9-4ed9-827b-86b010e6ae7a",
      "name": "Extract Slack URL1",
      "executeOnce": false
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -66464,
        -20864
      ],
      "id": "fc695ce2-94ea-4062-9b2e-93eb3e28438b",
      "name": "Respond to Webhook1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -66992,
        -20848
      ],
      "id": "098e2348-0a14-46ca-88f0-b874ab100ad3",
      "name": "If1"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -66720,
        -20864
      ],
      "id": "d066319c-cc0d-4c4c-b361-7ab3b4668e59",
      "name": "Return Slack Challenge1"
    },
    {
      "parameters": {
        "jsCode": "// Log input for debugging\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html) {\n  console.log(\"No HTML content found\");\n  return { error: \"No HTML content found\", availableFields: Object.keys(inputData) };\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- Step 1: Try JSON-LD structured data FIRST (best for mobile sites) ---\ntry {\n  const jsonBlocks = html.match(/<script[^>]+type=[\"']application\\/(ld\\+json|json)[\"'][^>]*>([\\s\\S]*?)<\\/script>/gi);\n  if (jsonBlocks) {\n    for (let block of jsonBlocks) {\n      try {\n        const clean = block.replace(/<script[^>]*>/i, \"\").replace(/<\\/script>/i, \"\").trim();\n        const parsed = JSON.parse(clean);\n        \n        // Recursive search for article content\n        function findContent(obj) {\n          if (!obj || typeof obj !== \"object\") return null;\n          if (obj.articleBody && typeof obj.articleBody === \"string\" && obj.articleBody.length > 200) return obj.articleBody;\n          if (obj.text && typeof obj.text === \"string\" && obj.text.length > 200) return obj.text;\n          if (obj.description && typeof obj.description === \"string\" && obj.description.length > 200) return obj.description;\n          \n          for (const key of Object.keys(obj)) {\n            const result = findContent(obj[key]);\n            if (result) return result;\n          }\n          return null;\n        }\n        \n        const result = findContent(parsed);\n        if (result && result.length > 200) {\n          text = result;\n          console.log(\"Found content in JSON-LD\");\n          break;\n        }\n      } catch (err) {\n        console.log(\"JSON parse error:\", err.message);\n      }\n    }\n  }\n} catch (e) {\n  console.log(\"JSON extraction error:\", e.message);\n}\n\n// --- Step 2: Try <article> tag ---\nif (text.length < 200) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      console.log(\"Found content in <article>\");\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 3: Try <p> and heading tags ---\nif (text.length < 200) {\n  console.log(\"Trying <p> and heading tags\");\n  try {\n    const matches = html.match(/<(p|h[1-6])[^>]*>(.*?)<\\/(p|h[1-6])>/gis);\n    if (matches) {\n      text = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => t.length > 20 && !t.match(/\\{|\\}/))  // Filter out CSS/JS\n        .join(\"\\n\\n\");\n      console.log(\"Found content in paragraphs\");\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 4: Check if we got CSS/JS instead of content ---\nconst cssJsIndicators = /\\{[\\s\\S]*?\\}|function\\s*\\(|\\.css|@media|var\\(--/;\nif (cssJsIndicators.test(text)) {\n  console.log(\"Detected CSS/JS code instead of article content\");\n  return { \n    error: \"Mobile site - unable to extract article content (got CSS/JS instead)\", \n    url: inputData.url || \"unknown\"\n  };\n}\n\n// --- Final validation ---\nif (!text || text.length < 200) {\n  console.log(\"Article body not found\");\n  return { \n    error: \"Article body not found (likely JS-rendered mobile site)\", \n    url: inputData.url || \"unknown\"\n  };\n}\n\nconsole.log(\"Extracted text length:\", text.length, \"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn { \n  article: text, \n  url: inputData.url || \"\",\n  originalLength: html.length, \n  extractedLength: text.length \n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -67344,
        -20528
      ],
      "id": "bafd0099-2960-4dbe-a3b9-0233f14e516d",
      "name": "HTML Extract1"
    },
    {
      "parameters": {
        "jsCode": "// === HELPER FUNCTION - AT TOP ===\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => b && b.length > 20);\n}\n\n// Log input\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\n// Get language from input\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\n\n// Aggressive cleaning\nlet s = raw\n  .replace(/```json\\s*/gi, \"\")\n  .replace(/```\\s*/g, \"\")\n  .replace(/\\*Automated with.*$/gim, \"\")\n  .replace(/^[^{]*/, \"\")\n  .replace(/[^}]*$/, \"\")\n  .replace(/-/g, \"-\")\n  .replace(/[\\r\\n]+/g, \" \")\n  .replace(/[\\u2018\\u2019]/g, \"'\")\n  .replace(/[\\u201C\\u201D]/g, '\"')\n  .replace(/\\s+/g, \" \")\n  .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n}\n\n// Try regex salvage if parse failed\nif (!obj || typeof obj !== \"object\") {\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language\n    }\n  }];\n}\n\n// Normal success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\n// Clean bullets\nbullets = cleanBullets(bullets, language);\n\n// Ensure exactly 5 bullets\nif (bullets.length > 5) bullets = bullets.slice(0, 5);\n\n// Language-specific default bullets\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים.\" \n  : language === \"ru\"\n  ? \"Дополнительные детали не найдены.\"\n  : \"No further details available.\";\n\nwhile (bullets.length < 5) {\n  bullets.push(defaultBullet);\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,\n    url: $json.url || null,\n    language: language,\n    source: $json.source || \"Local\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -65776,
        -20528
      ],
      "id": "12134ff6-1d77-4989-97c1-ff9e3b853907",
      "name": "Validator1"
    },
    {
      "parameters": {
        "jsCode": "const { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// --- Error case with multi-language support ---\nif (error) {\n  let errorMsg, sourceText, unknownText;\n  \n  if (language === \"he\") {\n    errorMsg = \"שגיאה בעיבוד המאמר\";\n    sourceText = \"מקור:\";\n    unknownText = \"לא ידוע\";\n  } else {\n    errorMsg = \"Error processing article\";\n    sourceText = \"Source:\";\n    unknownText = \"Unknown\";\n  }\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${sourceText} ${url ? `<${url}|${url}>` : unknownText}`\n    }\n  }];\n}\n\n// --- Clean title ---\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .trim();\n\n// --- Clean bullets ---\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    // Filter out wrong-language default bullets\n    if (language === \"he\" && b === \"No further details available.\") {\n      return false;\n    }\n    if (language === \"en\" && b === \"לא נמצאו פרטים נוספים.\") {\n      return false;\n    }\n    return b && b.length > 25;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\n// --- Guarantee 5 bullets with language-appropriate defaults ---\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים בנושא זה\" \n  : \"No further details available\";\n\nwhile (cleanBullets.length < 5) {\n  cleanBullets.push(defaultBullet);\n}\n\n// --- Build Slack message ---\nconst RTL = \"\\u200F\";\n\nif (language === \"he\") {\n  const titleLine = url \n    ? `:brain: סיכום: <${url}|${cleanTitle}>` \n    : `:brain: סיכום: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `${RTL}• ${b}${RTL}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  // English (including translated Russian and other languages)\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -65520,
        -20528
      ],
      "id": "77889b0f-d51c-4854-860f-2ba304b7f061",
      "name": "Formatter1"
    },
    {
      "parameters": {
        "url": "={{$json[\"url\"]}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -67616,
        -20528
      ],
      "id": "1207663e-bc40-4daf-ac2a-a6d24783f6dc",
      "name": "HTTP Request1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert summarization tool that creates accurate, fact-based summaries.\n\nLanguage: {{$json[\"language\"]}}\n\nCRITICAL: The source text below is in {{$json[\"language\"]}}. You MUST summarize it in the SAME language - do NOT translate.\n- If language is \"he\" → the text is Hebrew, summarize in Hebrew\n- If language is \"en\" → the text is English, summarize in English\n- If language is \"ru\" → the text is Russian, summarize in Russian\n\nTASK: Summarize the text into exactly 5 detailed bullet points IN THE SAME LANGUAGE AS THE SOURCE.\n\nACCURACY RULES:\n- ONLY use information explicitly stated in the source text\n- NEVER invent, assume, or add names, facts, or details not in the source\n- Use names and facts exactly as written in the source\n- Do NOT translate - keep the same language as input\n- Do NOT add context or background not present in the text\n\nBULLET REQUIREMENTS:\n- Each bullet: 3-5 complete sentences (40-60 words)\n- Start each bullet with • (bullet character)\n- Include only specific information from the source\n- Write in clear, journalistic style\n- Every sentence must be complete\n\nOUTPUT RULES:\n- Output ONLY valid JSON\n- NO markdown (no ```), NO extra text\n- Start with { and end with }\n\nRequired format:\n{\"title\":\"Title in same language as source\",\"bullets\":[\"• First detailed bullet in source language.\",\"• Second detailed bullet in source language.\",\"• Third detailed bullet in source language.\",\"• Fourth detailed bullet in source language.\",\"• Fifth detailed bullet in source language.\"]}\n\nText to summarize:\n{{ $json[\"chunk\"] }}\n\nCRITICAL: Write the summary in the SAME language as the text above. Do NOT translate.",
        "needsFallback": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -66576,
        -20528
      ],
      "id": "c3c6d61b-c624-4500-93be-7550f42efe71",
      "name": "AI Agent1"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -67568,
        -20848
      ],
      "id": "d59af382-4f2a-4b24-811a-8857540b516a",
      "name": "Webhook1",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"Chunker input article length:\", $json.article?.length || 0, \"Sample:\", $json.article?.slice(0, 500));\n\nconst CHUNK_SIZE = 2000;   // smaller than before\nconst OVERLAP = 150;\nconst MAX_CHUNKS = 20;\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ json: { url, chunk: text.slice(i, i + CHUNK_SIZE), index: chunks.length + 1 } });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Sample chunk:\", chunks[0]?.json.chunk.slice(0, 500));\nreturn chunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -67120,
        -20528
      ],
      "id": "632d1ef0-b86b-4ded-a86f-bba3afbd27cb",
      "name": "Chunker1",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -66064,
        -20528
      ],
      "id": "a7222a81-b79b-490c-9642-c835ddb3f917",
      "name": "Debug logger1",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// LANGUAGE DETECTOR NODE\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",\n      article: $json.article || \"\",\n      url: $json.url || \"\"\n    }\n  }];\n}\n\n// Count characters by script\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst cyrillicMatches = text.match(/[\\u0400-\\u04FF]/g) || [];\nconst latinMatches = text.match(/[a-zA-Z]/g) || [];\n\nconst totalChars = text.length;\nconst hebrewRatio = hebrewMatches.length / totalChars;\nconst cyrillicRatio = cyrillicMatches.length / totalChars;\nconst latinRatio = latinMatches.length / totalChars;\n\nlet detectedLanguage = \"en\";\nlet outputLanguage = \"en\";\n\n// Detect source language\nif (hebrewRatio > 0.15 && totalChars > 100) {\n  detectedLanguage = \"he\";\n  outputLanguage = \"he\";  // Hebrew stays Hebrew\n} else if (cyrillicRatio > 0.15 && totalChars > 100) {\n  detectedLanguage = \"ru\";\n  outputLanguage = \"en\";  // Russian → English\n} else if (latinRatio > 0.3) {\n  detectedLanguage = \"en\";\n  outputLanguage = \"en\";  // English stays English\n}\n\nconsole.log(`Detected: ${detectedLanguage}, Output: ${outputLanguage}, Hebrew: ${hebrewRatio.toFixed(3)}, Cyrillic: ${cyrillicRatio.toFixed(3)}, Total: ${totalChars}`);\n\nreturn [{\n  json: {\n    language: outputLanguage,\n    detectedLanguage: detectedLanguage,\n    article: $json.article || \"\",\n    url: $json.url || \"\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -66912,
        -20528
      ],
      "id": "244f3411-42bf-4ef5-b783-8ed67c0f0ddd",
      "name": "Language Detector1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "google/gemma-3-12b",
          "mode": "list",
          "cachedResultName": "google/gemma-3-12b"
        },
        "options": {
          "maxTokens": 1500,
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -66688,
        -20256
      ],
      "id": "7f32b309-654b-4ec5-9ffc-5549a1d7a113",
      "name": "AI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "openai/gpt-oss-20b",
          "mode": "list",
          "cachedResultName": "openai/gpt-oss-20b"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -66480,
        -20256
      ],
      "id": "74b73a55-5ad1-41fe-83f9-e2e7d524b873",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "openai/gpt-oss-20b",
          "mode": "list",
          "cachedResultName": "openai/gpt-oss-20b"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -68496,
        -21968
      ],
      "id": "1d06fa92-fdd3-4b7a-8479-12f4e7b9b20c",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    }
  ],
  "connections": {
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Debug logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Language Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Slack URL1": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Return Slack Challenge1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge1": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract1": {
      "main": [
        [
          {
            "node": "Chunker1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator1": {
      "main": [
        [
          {
            "node": "Formatter1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter1": {
      "main": [
        [
          {
            "node": "Send a message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "HTML Extract1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent1": {
      "main": [
        [
          {
            "node": "Debug logger1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook1": {
      "main": [
        [
          {
            "node": "Extract Slack URL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker1": {
      "main": [
        [
          {
            "node": "Language Detector1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger1": {
      "main": [
        [
          {
            "node": "Validator1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector1": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "fb4a4ebc-b8ed-40ca-80bf-2b6a0361beb9",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-09-02T14:14:42.897Z",
      "updatedAt": "2025-09-02T14:14:42.897Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "NptNxIUgBjUJaRfd"
    }
  ],
  "tags": []
}