{
  "updatedAt": "2025-11-04T13:51:15.000Z",
  "createdAt": "2025-09-02T14:14:42.893Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Automatic Slack Summary",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  let event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event subtype:', event.subtype);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) IMPORTANT: Skip URL unfurl events and other non-user messages\n  const skipSubtypes = [\n    'bot_message',\n    'message_deleted', \n    'channel_join',\n    'channel_leave',\n    'channel_topic',\n    'channel_purpose',\n    'channel_name',\n    'channel_archive',\n    'channel_unarchive',\n    'group_join',\n    'group_leave',\n    'file_share',\n    'file_comment',\n    'file_mention',\n    'pinned_item',\n    'unpinned_item'\n  ];\n  \n  // Skip these subtypes entirely\n  if (event.subtype && skipSubtypes.includes(event.subtype)) {\n    console.log('Skipping non-user message subtype:', event.subtype);\n    return null;\n  }\n\n  // 4) Handle message_changed events specially\n  if (event.subtype === 'message_changed') {\n    // Check if this is just a URL unfurl update\n    if (event.message && event.previous_message) {\n      const prevText = event.previous_message.text || '';\n      const newText = event.message.text || '';\n      \n      // If text is the same, it's likely just an unfurl update\n      if (prevText === newText) {\n        console.log('Skipping message_changed with same text (likely unfurl)');\n        return null;\n      }\n      \n      // Check if attachments were added (another sign of unfurl)\n      if (!event.previous_message.attachments && event.message.attachments) {\n        console.log('Skipping message_changed with new attachments (likely unfurl)');\n        return null;\n      }\n    }\n    \n    // Use the edited message content\n    event = event.message;\n  }\n\n  // 5) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 6) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 7) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 8) URL EXTRACTION\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Extract URLs using various patterns\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate URLs\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  // 9) ENHANCED DEDUPLICATION\n  let isDuplicateUrl = false;\n  \n  try {\n    const staticData = $getWorkflowStaticData('global');\n    \n    // Initialize storage\n    if (!staticData.processedUrls) {\n      staticData.processedUrls = {};\n    }\n    \n    if (!staticData.processedMessages) {\n      staticData.processedMessages = {};\n    }\n    \n    // Create unique message key using timestamp and user\n    // This is more reliable than event_id which can change\n    const messageKey = `${event.user}_${event.ts}`;\n    \n    // Check if we've seen this exact message before\n    if (staticData.processedMessages[messageKey]) {\n      console.log('DUPLICATE MESSAGE DETECTED:', messageKey);\n      return null;\n    }\n    \n    // Mark message as processed\n    staticData.processedMessages[messageKey] = Date.now();\n    \n    // Check URL deduplication (4 hours window)\n    const fourHoursAgo = Date.now() - 14400000;\n    const lastProcessed = staticData.processedUrls[firstUrl];\n    \n    if (lastProcessed && lastProcessed > fourHoursAgo) {\n      console.log('DUPLICATE URL within 4 hours:', firstUrl);\n      console.log('Last processed:', new Date(lastProcessed).toISOString());\n      isDuplicateUrl = true;\n    } else {\n      // Mark URL as processed\n      staticData.processedUrls[firstUrl] = Date.now();\n      console.log('URL marked as processed:', firstUrl);\n    }\n    \n    // Clean old entries (keep last 2 days)\n    const twoDaysAgo = Date.now() - 172800000;\n    \n    // Clean old URLs\n    Object.keys(staticData.processedUrls).forEach(url => {\n      if (staticData.processedUrls[url] < twoDaysAgo) {\n        delete staticData.processedUrls[url];\n      }\n    });\n    \n    // Clean old messages\n    Object.keys(staticData.processedMessages).forEach(msgKey => {\n      if (staticData.processedMessages[msgKey] < twoDaysAgo) {\n        delete staticData.processedMessages[msgKey];\n      }\n    });\n    \n    // Log cache status\n    console.log('Cache status:', {\n      urls: Object.keys(staticData.processedUrls).length,\n      messages: Object.keys(staticData.processedMessages).length\n    });\n    \n  } catch (e) {\n    console.log('Error in deduplication:', e.message);\n  }\n  \n  // Handle duplicate URLs\n  if (isDuplicateUrl) {\n    return {\n      json: {\n        isDuplicate: true,\n        text: `ℹ️ This URL was already summarized recently.\\n\\n<${firstUrl}|${firstUrl}>`,\n        slack_channel: event.channel,\n        slack_user: event.user,\n        slack_ts: event.ts,\n        slack_thread_ts: event.thread_ts\n      },\n      pairedItem: { item: index }\n    };\n  }\n  \n  // Return data for processing\n  return {\n    json: {\n      isDuplicate: false,\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user, \n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1888,
        176
      ],
      "id": "5fee59eb-6fd5-439b-a925-c9bfffcc4028",
      "name": "Extract Slack URL",
      "executeOnce": false
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -608,
        160
      ],
      "id": "24257d07-e11b-4269-8a79-bbd33aeae3d9",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        160
      ],
      "id": "bbf33193-08da-4d6e-b5eb-fe106809c066",
      "name": "Return Slack Challenge"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced HTML Extract - Better for news sites\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconst url = inputData.url || \"\";\n\nconsole.log(\"URL:\", url);\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html || html.length < 100) {\n  console.log(\"No HTML content found\");\n  return [{ \n    json: {\n      error: \"No HTML content received from website\",\n      url: url\n    }\n  }];\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- YNET SPECIFIC: Try structured data first ---\nconsole.log(\"Trying JSON-LD structured data\");\ntry {\n  const jsonLdMatch = html.match(/<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i);\n  if (jsonLdMatch) {\n    const jsonData = JSON.parse(jsonLdMatch[1]);\n    if (jsonData.articleBody) {\n      text = jsonData.articleBody;\n      console.log(\"✅ Found content in JSON-LD\");\n    }\n  }\n} catch (e) {\n  console.log(\"JSON-LD extraction failed:\", e.message);\n}\n\n// --- Try meta description for headline context ---\nlet metaDescription = \"\";\ntry {\n  const metaMatch = html.match(/<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)[\"']/i) ||\n                    html.match(/<meta[^>]*content=[\"']([^\"']+)[\"'][^>]*name=[\"']description[\"']/i);\n  if (metaMatch) {\n    metaDescription = metaMatch[1];\n  }\n} catch (e) {}\n\n// --- Step 1: Try <article> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, \"\")\n        .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*comment[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (text.length > 500) {\n        console.log(\"✅ Found content in <article>\");\n      } else {\n        text = \"\";\n      }\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 2: Try <main> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <main> tag\");\n  const mainMatch = html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n  if (mainMatch) {\n    const extracted = mainMatch[1]\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n      .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n      .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n      .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n      .replace(/<[^>]+>/g, \" \")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    if (extracted.length > text.length) {\n      text = extracted;\n      console.log(\"✅ Found content in <main>\");\n    }\n  }\n}\n\n// --- Step 3: Try common Israeli news site patterns ---\nif (text.length < 500) {\n  console.log(\"Trying Israeli news site patterns\");\n  const contentPatterns = [\n    // Ynet specific\n    /<div[^>]*class=\"[^\"]*art_body[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*article_text[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*text_block[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    // Generic patterns\n    /<div[^>]*class=\"[^\"]*(?:article-body|post-content|entry-content|main-content|article-content|article__content|post-body|content-body|story-body)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*id=\"[^\"]*(?:article|content|main|post|story)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i\n  ];\n  \n  for (const pattern of contentPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      const extracted = match[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*(?:ad|banner|social|share|comment)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (extracted.length > text.length && extracted.length > 500) {\n        text = extracted;\n        console.log(\"✅ Found content in news site pattern\");\n        break;\n      }\n    }\n  }\n}\n\n// --- Step 4: Aggressive paragraph extraction ---\nif (text.length < 500) {\n  console.log(\"Trying aggressive paragraph extraction\");\n  try {\n    // Get all paragraphs\n    const matches = html.match(/<p[^>]*>(.*?)<\\/p>/gis);\n    if (matches && matches.length > 5) {\n      const paragraphs = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => {\n          const lowerText = t.toLowerCase();\n          return t.length > 50 && \n                 !lowerText.includes('cookie') &&\n                 !lowerText.includes('פרטיות') &&\n                 !lowerText.includes('privacy') &&\n                 !lowerText.includes('תנאי שימוש') &&\n                 !lowerText.includes('הרשמה') &&\n                 !lowerText.includes('subscribe') &&\n                 !lowerText.includes('newsletter');\n        });\n      \n      if (paragraphs.length >= 5) {\n        // Add meta description as headline if available\n        text = (metaDescription ? metaDescription + \"\\n\\n\" : \"\") + paragraphs.join(\"\\n\\n\");\n        console.log(\"✅ Found content in paragraphs\");\n      }\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 5: Check for JavaScript-rendered content indicators ---\nif (text.length < 500) {\n  console.log(\"⚠️ Checking for JS-heavy site indicators\");\n  \n  const jsIndicators = [\n    'window.__INITIAL_STATE__',\n    'window.__PRELOADED_STATE__',\n    'data-react-root',\n    'id=\"__next\"',\n    'id=\"root\"',\n    /__NUXT__/,\n    /window\\.__APOLLO_STATE__/\n  ];\n  \n  const hasJsIndicators = jsIndicators.some(indicator => {\n    if (typeof indicator === 'string') {\n      return html.includes(indicator);\n    }\n    return indicator.test(html);\n  });\n  \n  if (hasJsIndicators) {\n    return [{ \n      json: {\n        error: \"This site uses heavy JavaScript rendering. Content cannot be extracted without a browser.\",\n        url: url,\n        suggestion: \"Try sharing a direct link to the article text or PDF version\"\n      }\n    }];\n  }\n}\n\n// --- Step 6: Clean extracted text ---\nif (text.length > 0) {\n  text = text\n    // Remove author bios\n    .replace(/is a (writer|journalist|author|reporter|editor).*?(\\.|$)/gi, \"\")\n    .replace(/writes? (about|for|on).*?(\\.|$)/gi, \"\")\n    .replace(/based in.*?(\\.|$)/gi, \"\")\n    .replace(/כתב(?:ת)? ב.*?(\\.|$)/gi, \"\")\n    // Remove common footer/header text\n    .replace(/all rights reserved/gi, \"\")\n    .replace(/כל הזכויות שמורות/gi, \"\")\n    .replace(/copyright \\d{4}/gi, \"\")\n    .replace(/©\\s*\\d{4}/gi, \"\")\n    // Remove social media prompts\n    .replace(/follow us on.*/gi, \"\")\n    .replace(/עקבו אחרינו.*/gi, \"\")\n    // Clean whitespace\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\n// --- Final validation ---\nif (!text || text.length < 300) {\n  console.log(\"❌ Article body not found or too short\");\n  \n  // Provide specific error message\n  let errorDetail = \"Could not extract article text. \";\n  \n  if (html.includes('נדרשת הרשמה') || html.includes('subscription required')) {\n    errorDetail += \"Site requires subscription or login.\";\n  } else if (html.length < 5000) {\n    errorDetail += \"Page content too small - might be blocked or redirected.\";\n  } else {\n    errorDetail += \"Site may use JavaScript rendering or paywall.\";\n  }\n  \n  return [{ \n    json: {\n      error: errorDetail,\n      url: url,\n      htmlLength: html.length,\n      extractedLength: text.length\n    }\n  }];\n}\n\nconsole.log(`✅ Successfully extracted ${text.length} characters`);\nconsole.log(\"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn [{ \n  json: {\n    article: text, \n    url: url,\n    originalLength: html.length, \n    extractedLength: text.length \n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1952,
        496
      ],
      "id": "e55983be-a403-4af8-bbb7-ee600937cf0a",
      "name": "HTML Extract"
    },
    {
      "parameters": {
        "jsCode": "// === HELPER FUNCTION - AT TOP ===\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => b && b.length > 20); // Filter short/empty bullets\n}\n\n// Log input\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\n// Get the raw output from AI Agent\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\n// Get language from input\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\nconsole.log(\"Raw content length:\", raw.length);\nconsole.log(\"Raw content preview:\", raw.slice(0, 200));\n\n// Clean the markdown code blocks and extract JSON\nlet s = raw;\n\n// Remove markdown code blocks\ns = s.replace(/```json\\s*/gi, \"\");\ns = s.replace(/```\\s*/g, \"\");\n\n// Remove any text before the first {\nconst startIdx = s.indexOf('{');\nif (startIdx > -1) {\n  s = s.substring(startIdx);\n}\n\n// Remove any text after the last }\nconst endIdx = s.lastIndexOf('}');\nif (endIdx > -1) {\n  s = s.substring(0, endIdx + 1);\n}\n\n// Clean up special characters\ns = s.replace(/[\\r\\n]+/g, \" \")\n     .replace(/[\\u2018\\u2019]/g, \"'\")\n     .replace(/[\\u201C\\u201D]/g, '\"')\n     .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n  console.log(\"Successfully parsed JSON:\", obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n  console.log(\"Attempting to parse with eval as fallback...\");\n  \n  // Try regex salvage if parse failed\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    console.log(\"Extracted via regex - title:\", title, \"bullets count:\", bullets.length);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language\n    }\n  }];\n}\n\n// Normal success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\nconsole.log(\"Extracted title:\", title);\nconsole.log(\"Extracted bullets count:\", bullets.length);\n\n// Clean bullets\nbullets = cleanBullets(bullets, language);\n\n// Ensure exactly 5 bullets\nif (bullets.length > 5) bullets = bullets.slice(0, 5);\n\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים.\" \n  : \"No further details available.\";\n\nwhile (bullets.length < 5) {\n  bullets.push(defaultBullet);\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,\n    url: $json.url || null,\n    language: language,\n    source: $json.source || \"Local\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        496,
        512
      ],
      "id": "7bf1f1c2-6f24-466a-9598-e4031d36f6ca",
      "name": "Validator"
    },
    {
      "parameters": {
        "jsCode": "const { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// --- Error case ---\nif (error) {\n  const errorMsg = language === \"he\" ? \"שגיאה בעיבוד המאמר\" : \"Error processing article\";\n  const sourceText = language === \"he\" ? \"מקור:\" : \"Source:\";\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${sourceText} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : \"Unknown\")}`\n    }\n  }];\n}\n\n// --- Clean title ---\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .replace(/^תקציר[:\\s]+/i, \"\")\n  .replace(/^סיכום[:\\s]+/i, \"\")\n  .replace(/^summary[:\\s]+/i, \"\")\n  .trim();\n\n// --- Clean bullets ---\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    if (language === \"he\" && (\n      b === \"No further details available.\" || \n      b === \"No further details available\"\n    )) {\n      return false;\n    }\n    return b && b.length > 25;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים בנושא זה\" \n  : \"No further details available\";\n\nwhile (cleanBullets.length < 5) {\n  cleanBullets.push(defaultBullet);\n}\n\n// --- Track metrics ---\nconst metrics = $getWorkflowStaticData('global').metrics || { total: 0, success: 0 };\nmetrics.total++;\nmetrics.success++;\n$getWorkflowStaticData('global').metrics = metrics;\nconsole.log(`Success rate: ${(metrics.success/metrics.total*100).toFixed(1)}%`);\n\n// --- Build Slack message ---\nconst RLM = \"\\u200F\"; // Right-to-Left Mark\nconst LRM = \"\\u200E\"; // Left-to-Right Mark\n\nif (language === \"he\") {\n  // Improved regex to wrap English, numbers, and special characters\n  function wrapEnglish(text) {\n    // Match English words, numbers with decimals/commas, and mixed content\n    return text.replace(/([A-Za-z0-9]+(?:[.,:/\\-][A-Za-z0-9]+)*)/g, `${LRM}$1${LRM}`);\n  }\n  \n  const wrappedTitle = wrapEnglish(cleanTitle);\n  \n  // Hebrew: NO \"סיכום:\" prefix, just emoji + title\n  const titleLine = url \n    ? `${RLM}:brain: <${url}|${wrappedTitle}>` \n    : `${RLM}:brain: ${wrappedTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => {\n    const wrappedBullet = wrapEnglish(b);\n    return `${RLM}• ${wrappedBullet}`;\n  });\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  // English: Keep \"Summary:\" prefix\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        752,
        512
      ],
      "id": "092c58d0-0eaf-42fa-acd8-be61067ad41e",
      "name": "Formatter"
    },
    {
      "parameters": {
        "url": "={{$json.fetchUrl}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2176,
        496
      ],
      "id": "afb6cbc3-d3a7-46fa-a77d-f03bf0571755",
      "name": "HTTP Request",
      "retryOnFail": false,
      "executeOnce": false,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert summarization tool that creates accurate, fact-based summaries.\n\nTARGET LANGUAGE: {{$json[\"language\"]}}\n\nCRITICAL LANGUAGE RULE:\nYou MUST write your summary in {{$json[\"language\"]}} regardless of the source text language.\n- \"he\" = Hebrew (עברית) \n- \"en\" = English\n- \"ru\" = Russian (Русский)\n- Source text may be in ANY language, but output MUST be in {{$json[\"language\"]}}\n\nTASK: Create exactly 5 detailed bullet points summarizing the key information.\n\nACCURACY REQUIREMENTS:\n- Extract ONLY information explicitly stated in the source text\n- NEVER add, invent, or infer any names, facts, dates, or details\n- Preserve names and terminology exactly as they appear in source\n- No external context, background information, or interpretations\n- If information is unclear or ambiguous, reflect that ambiguity\n\nBULLET POINT SPECIFICATIONS:\n- Exactly 5 bullets, no more, no less\n- Each bullet: 3-5 complete sentences (40-60 words)\n- Start each with: • (bullet character)\n- Use clear, factual, journalistic language\n- Each sentence must be grammatically complete\n- Prioritize most important information if text is lengthy\n\nOUTPUT FORMAT:\n- Pure JSON only - no markdown, no backticks, no explanations\n- Must parse as valid JSON\n- Use this exact structure:\n\n{\"title\":\"[Descriptive title in {{$json[\"language\"]}}]\",\"bullets\":[\"• [Bullet 1: 3-5 sentences, 40-60 words]\",\"• [Bullet 2: 3-5 sentences, 40-60 words]\",\"• [Bullet 3: 3-5 sentences, 40-60 words]\",\"• [Bullet 4: 3-5 sentences, 40-60 words]\",\"• [Bullet 5: 3-5 sentences, 40-60 words]\"]}\n\nTEXT TO SUMMARIZE:\n{{ $json[\"chunk\"] }}\n\nREMEMBER: Output in {{$json[\"language\"]}} language ONLY, regardless of source language.",
        "needsFallback": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -304,
        512
      ],
      "id": "d6238077-e8c9-4c51-9908-4f77402b939f",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -2128,
        176
      ],
      "id": "04b6a40b-3777-4016-9373-1c5d10009a96",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"Chunker input article length:\", $json.article?.length || 0, \"Sample:\", $json.article?.slice(0, 500));\n\nconst CHUNK_SIZE = 5000;   // smaller than before\nconst OVERLAP = 150;\nconst MAX_CHUNKS = 10;\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ json: { url, chunk: text.slice(i, i + CHUNK_SIZE), index: chunks.length + 1 } });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Sample chunk:\", chunks[0]?.json.chunk.slice(0, 500));\nreturn chunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1056,
        512
      ],
      "id": "689ac001-d80e-4c43-8630-78aec0708726",
      "name": "Chunker",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        512
      ],
      "id": "ed77c720-ede5-4b37-8c54-766f1d4a6491",
      "name": "Debug logger",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// LANGUAGE DETECTOR NODE\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",  // Default fallback\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count Hebrew characters\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\n\n// Count Cyrillic characters (Russian)\nconst cyrillicMatches = text.match(/[\\u0400-\\u04FF]/g) || [];\nconst cyrillicChars = cyrillicMatches.length;\n\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\nconst cyrillicRatio = cyrillicChars / totalChars;\n\n// Detect language - treat Russian as English for summarization\nlet language = \"en\";\nif (hebrewRatio > 0.2 && totalChars > 200) {\n  language = \"he\";\n} else if (cyrillicRatio > 0.2 && totalChars > 200) {\n  language = \"en\";  // Russian articles will be summarized in English\n}\n\nconsole.log(`Language detected: ${language}, Hebrew: ${hebrewChars}, Cyrillic: ${cyrillicChars}, Total: ${totalChars}`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        512
      ],
      "id": "92582098-eb49-4720-8f4b-b88a99f531bb",
      "name": "Language Detector"
    },
    {
      "parameters": {
        "jsCode": "// Format Error Message - FIXED\nconst error = $json.error || \"Unknown error\";\nconst url = $json.url || $input.first()?.json?.url || 'Unknown URL';\nconst language = $json.language || 'en';\n\nconsole.log(\"Error formatting - URL:\", url, \"Error:\", error);\n\nconst errorMsg = language === 'he' \n  ? '⚠️ נכשל בסיכום המאמר'\n  : '⚠️ Failed to summarize article';\n\nconst detailMsg = language === 'he'\n  ? `סיבה: ${error}`\n  : `Reason: ${error}`;\n\nconst sourceText = language === 'he' ? 'מקור:' : 'Source:';\n\nreturn [{\n  json: {\n    text: `${errorMsg}\\n${detailMsg}\\n\\n${sourceText} <${url}|${url}>`\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        256
      ],
      "id": "9d517dbd-494a-4e04-bbb2-7c82af3947e4",
      "name": "Format Error Message"
    },
    {
      "parameters": {
        "amount": 2
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -592,
        512
      ],
      "id": "80017d77-752e-4d48-b3a6-ae16dbc568e6",
      "name": "Wait",
      "webhookId": "10236448-b9ab-466e-b2f5-cbe1633592d1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1552,
        176
      ],
      "id": "8d0a8370-bc64-479e-be11-9301fd453bd0",
      "name": "Check URL Verification"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a8b1824d-7f4a-44b2-9117-e9ffce906f69",
              "leftValue": "={{ $json.isDuplicate }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1728,
        -160
      ],
      "id": "f42bf667-0fc4-4351-a3cb-88dad784f7cb",
      "name": "Check Duplicate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "5e3db3e5-dc18-47c5-9c94-1086878f8f31",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1728,
        496
      ],
      "id": "15abb7de-adbc-4e6f-a8fb-b9f8e15dfb71",
      "name": "Check Extract Error"
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {
          "includeLinkToWorkflow": "={{ false }}"
        }
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        560,
        -176
      ],
      "id": "577daea5-5192-4860-8ff0-d5331cc2742b",
      "name": "Send Summary",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -528,
        -176
      ],
      "id": "7dab1be1-58a4-434e-9889-e13745d26f8b",
      "name": "Send Duplicate Notice",
      "webhookId": "214e8692-2d7d-4ade-9ec1-77708747f604",
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "google/gemma-3-12b",
          "mode": "list",
          "cachedResultName": "google/gemma-3-12b"
        },
        "options": {
          "maxTokens": 1500,
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -368,
        784
      ],
      "id": "82969969-6153-406f-9b6d-ff82576e1f0d",
      "name": "Gemma 3 12B",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    },
    {
      "parameters": {
        "model": "openai/gpt-5-nano",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -192,
        784
      ],
      "id": "fe87bc4b-9e2b-4403-bf2b-7ad1741d9a1f",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "hGAnvpSAhWRbFktq",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pre-fetch URL Checker\nconst url = $json.url;\n\n// Check if URL is from known problematic sites\nconst problematicSites = {\n  'ynet.co.il': 'mobile',\n  'mako.co.il': 'mobile',\n  'walla.co.il': 'mobile'\n};\n\nlet strategy = 'desktop';\ntry {\n  const domain = new URL(url).hostname;\n  for (const [site, strat] of Object.entries(problematicSites)) {\n    if (domain.includes(site)) {\n      strategy = strat;\n      console.log(`Using ${strategy} strategy for ${domain}`);\n      break;\n    }\n  }\n} catch (e) {}\n\n// For mobile strategy, try to convert URL to mobile version\nlet fetchUrl = url;\nif (strategy === 'mobile' && url.includes('ynet.co.il')) {\n  // Some sites have mobile versions that are easier to parse\n  fetchUrl = url.replace('www.ynet', 'm.ynet');\n}\n\nreturn [{\n  json: {\n    url: url,\n    fetchUrl: fetchUrl,\n    strategy: strategy\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2480,
        496
      ],
      "id": "65b0266d-47c8-464a-a63a-41c2ba0b4d0a",
      "name": "Code in JavaScript"
    }
  ],
  "connections": {
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "Check Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "Check Extract Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Debug logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Language Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Error Message": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check URL Verification": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicate": {
      "main": [
        [
          {
            "node": "Send Duplicate Notice",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check URL Verification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Extract Error": {
      "main": [
        [
          {
            "node": "Format Error Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemma 3 12B": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Asia/Jerusalem",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "global": {
      "metrics": {
        "total": 100,
        "success": 100
      },
      "processedUrls": {
        "https://gizmodo.com/avengers-secret-wars-original-release-date-marvel-2000683125": 1762543363647,
        "https://news.walla.co.il/item/3792782": 1762602320150,
        "https://news.walla.co.il/item/3792844": 1762628622883,
        "https://www.espn.com/nba/recap?gameId=401810042": 1762662998737,
        "https://gizmodo.com/iphone-17-pro-max-review-practical-perfection-with-two-capital-ps-2000660140": 1762692081783
      },
      "processedEvents": {
        "1762243942.321019-undefined": 1762243945452
      },
      "processedMessages": {
        "U08AYDL2FQD_1762543362.115629": 1762543363647,
        "U08AYDL2FQD_1762602318.630239": 1762602320150,
        "U08AYDL2FQD_1762628621.188399": 1762628622882,
        "U08AYDL2FQD_1762662996.733479": 1762662998737,
        "U08AYDL2FQD_1762692080.106349": 1762692081783
      }
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "b7818d9b-7ba7-4faa-b7d1-69e2b4fb99d7",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-10-31T09:14:00.820Z",
      "createdAt": "2025-10-31T09:14:00.820Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "pWTWmuHnmIHw48U9"
    }
  ],
  "tags": []
}