{
  "updatedAt": "2026-02-07T17:57:40.768Z",
  "createdAt": "2025-09-02T14:14:42.893Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Slack Article Summarizer",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "model": "openai/gpt-5-nano",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -2240,
        2336
      ],
      "id": "985b839a-8232-4a4b-b907-0afaab717095",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "hGAnvpSAhWRbFktq",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -2624,
        1728
      ],
      "id": "6adf1c7c-ba60-4c68-a3da-45b70b1bf2c8",
      "name": "Respond to Webhook1"
    },
    {
      "parameters": {
        "url": "={{$json.fetchUrl}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4192,
        2064
      ],
      "id": "b533795f-6961-4f1f-82fd-1bf0b825d7d9",
      "name": "HTTP Request1",
      "retryOnFail": false,
      "executeOnce": false,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// Format Error Message - FIXED\nconst error = $json.error || \"Unknown error\";\nconst url = $json.url || $input.first()?.json?.url || 'Unknown URL';\nconst language = $json.language || 'en';\n\nconsole.log(\"Error formatting - URL:\", url, \"Error:\", error);\n\nconst errorMessages = {\n  he: '⚠️ נכשל בסיכום המאמר',\n  ru: '⚠️ Не удалось обобщить статью',\n  en: '⚠️ Failed to summarize article'\n};\n\nconst reasonText = {\n  he: 'סיבה:',\n  ru: 'Причина:',\n  en: 'Reason:'\n};\n\nconst sourceText = {\n  he: 'מקור:',\n  ru: 'Источник:',\n  en: 'Source:'\n};\n\nconst errorMsg = errorMessages[language] || errorMessages.en;\nconst reason = reasonText[language] || reasonText.en;\nconst source = sourceText[language] || sourceText.en;\n\nreturn [{\n  json: {\n    text: `${errorMsg}\\n${reason} ${error}\\n\\n${source} <${url}|${url}>`\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2144,
        1824
      ],
      "id": "f104fe36-062b-45b7-ba4d-f38226e50792",
      "name": "Format Error Message1"
    },
    {
      "parameters": {
        "amount": 2
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -2608,
        2080
      ],
      "id": "ef611f4b-3a5d-4870-8569-5a7aa49eb6de",
      "name": "Wait1",
      "webhookId": "10236448-b9ab-466e-b2f5-cbe1633592d1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a summarization tool.\n\nSummarize the following text in {{$json[\"language\"]}}.\n- If \"he\" → write the title and bullets in Hebrew.\n- If \"en\" → write the title and bullets in English.\n\nNever translate — always summarize in the language provided by {{$json[\"language\"]}}.\n\nSummarize into exactly 5 detailed bullet points and a short title.\n\n⚠️ Important:\n- Output must be ONLY valid JSON (no extra text).\n- Always return 5 bullet points.\n- Each bullet should be 40-60 words (3-5 complete sentences).\n- Include specific details: names, dates, numbers, locations, organizations.\n- Provide context and explain why events matter.\n- Write complete sentences with proper grammar.\n- Do NOT include bullet characters (•) in your output.\n- If the text is unclear or empty, still return JSON with a generic title and 5 short placeholders.\n\nFormat:\n{\n  \"title\": \"Short descriptive title (same language)\",\n  \"bullets\": [\n    \"First detailed point with 3-5 complete sentences including names and facts.\",\n    \"Second detailed point with 3-5 complete sentences including context.\",\n    \"Third detailed point with 3-5 complete sentences including background.\",\n    \"Fourth detailed point with 3-5 complete sentences including reactions.\",\n    \"Fifth detailed point with 3-5 complete sentences including implications.\"\n  ]\n}\n\nText:\n{{ $json[\"chunk\"] }}",
        "needsFallback": true,
        "options": {
          "systemMessage": "You are an expert summarization AI. Always output valid JSON only, no markdown."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        -2320,
        2080
      ],
      "id": "b73a8c93-ee02-497a-9fae-c1ac61bf71a4",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -4144,
        1744
      ],
      "id": "624fbe05-78dc-4c16-b301-f6c7085dbeff",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a8b1824d-7f4a-44b2-9117-e9ffce906f69",
              "leftValue": "={{ $json.isDuplicate }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3744,
        1408
      ],
      "id": "6ad70a29-e025-49d8-bf2b-5c73d92dbed5",
      "name": "Check Duplicate"
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -2544,
        1392
      ],
      "id": "a260db80-7643-49aa-b5cd-138488573e29",
      "name": "Send Duplicate Notice",
      "webhookId": "214e8692-2d7d-4ade-9ec1-77708747f604",
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {
          "includeLinkToWorkflow": "={{ false }}"
        }
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -1456,
        1392
      ],
      "id": "dea2db3a-1164-4226-bd67-a63ee964d163",
      "name": "Send Summary",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  let event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event subtype:', event.subtype);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) IMPORTANT: Skip URL unfurl events and other non-user messages\n  const skipSubtypes = [\n    'bot_message',\n    'message_deleted', \n    'channel_join',\n    'channel_leave',\n    'channel_topic',\n    'channel_purpose',\n    'channel_name',\n    'channel_archive',\n    'channel_unarchive',\n    'group_join',\n    'group_leave',\n    'file_share',\n    'file_comment',\n    'file_mention',\n    'pinned_item',\n    'unpinned_item'\n  ];\n  \n  // Skip these subtypes entirely\n  if (event.subtype && skipSubtypes.includes(event.subtype)) {\n    console.log('Skipping non-user message subtype:', event.subtype);\n    return null;\n  }\n\n  // 4) Handle message_changed events specially\n  if (event.subtype === 'message_changed') {\n    // Check if this is just a URL unfurl update\n    if (event.message && event.previous_message) {\n      const prevText = event.previous_message.text || '';\n      const newText = event.message.text || '';\n      \n      // If text is the same, it's likely just an unfurl update\n      if (prevText === newText) {\n        console.log('Skipping message_changed with same text (likely unfurl)');\n        return null;\n      }\n      \n      // Check if attachments were added (another sign of unfurl)\n      if (!event.previous_message.attachments && event.message.attachments) {\n        console.log('Skipping message_changed with new attachments (likely unfurl)');\n        return null;\n      }\n    }\n    \n    // Use the edited message content\n    event = event.message;\n  }\n\n  // 5) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 6) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 7) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 8) URL EXTRACTION\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Extract URLs using various patterns\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate URLs\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  // 9) ENHANCED DEDUPLICATION\n  let isDuplicateUrl = false;\n  \n  try {\n    const staticData = $getWorkflowStaticData('global');\n    \n    // Initialize storage\n    if (!staticData.processedUrls) {\n      staticData.processedUrls = {};\n    }\n    \n    if (!staticData.processedMessages) {\n      staticData.processedMessages = {};\n    }\n    \n    // Create unique message key using timestamp and user\n    // This is more reliable than event_id which can change\n    const messageKey = `${event.user}_${event.ts}`;\n    \n    // Check if we've seen this exact message before\n    if (staticData.processedMessages[messageKey]) {\n      console.log('DUPLICATE MESSAGE DETECTED:', messageKey);\n      return null;\n    }\n    \n    // Mark message as processed\n    staticData.processedMessages[messageKey] = Date.now();\n    \n    // Check URL deduplication (4 hours window)\n    const fourHoursAgo = Date.now() - 14400000;\n    const lastProcessed = staticData.processedUrls[firstUrl];\n    \n    if (lastProcessed && lastProcessed > fourHoursAgo) {\n      console.log('DUPLICATE URL within 4 hours:', firstUrl);\n      console.log('Last processed:', new Date(lastProcessed).toISOString());\n      isDuplicateUrl = true;\n    } else {\n      // Mark URL as processed\n      staticData.processedUrls[firstUrl] = Date.now();\n      console.log('URL marked as processed:', firstUrl);\n    }\n    \n    // Clean old entries (keep last 2 days)\n    const twoDaysAgo = Date.now() - 172800000;\n    \n    // Clean old URLs\n    Object.keys(staticData.processedUrls).forEach(url => {\n      if (staticData.processedUrls[url] < twoDaysAgo) {\n        delete staticData.processedUrls[url];\n      }\n    });\n    \n    // Clean old messages\n    Object.keys(staticData.processedMessages).forEach(msgKey => {\n      if (staticData.processedMessages[msgKey] < twoDaysAgo) {\n        delete staticData.processedMessages[msgKey];\n      }\n    });\n    \n    // Log cache status\n    console.log('Cache status:', {\n      urls: Object.keys(staticData.processedUrls).length,\n      messages: Object.keys(staticData.processedMessages).length\n    });\n    \n  } catch (e) {\n    console.log('Error in deduplication:', e.message);\n  }\n  \n  // Handle duplicate URLs\n  if (isDuplicateUrl) {\n    return {\n      json: {\n        isDuplicate: true,\n        text: `ℹ️ This URL was already summarized recently.\\n\\n<${firstUrl}|${firstUrl}>`,\n        slack_channel: event.channel,\n        slack_user: event.user,\n        slack_ts: event.ts,\n        slack_thread_ts: event.thread_ts\n      },\n      pairedItem: { item: index }\n    };\n  }\n  \n  // Return data for processing\n  return {\n    json: {\n      isDuplicate: false,\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user, \n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3904,
        1744
      ],
      "id": "e050967c-5da5-4a76-afae-97e4cbdf6c6b",
      "name": "Extract Slack URL",
      "executeOnce": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3568,
        1744
      ],
      "id": "196c147f-a75c-4d8d-b8d1-f9e59675a08a",
      "name": "Check URL Verification"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2880,
        1728
      ],
      "id": "abe42212-582d-4764-a676-7c30f27f4539",
      "name": "Return Slack Challenge"
    },
    {
      "parameters": {
        "jsCode": "// Pre-fetch URL Checker\nconst url = $json.url;\n\n// Check if URL is from known problematic sites\nconst problematicSites = {\n  'ynet.co.il': 'mobile',\n  'mako.co.il': 'mobile',\n  'walla.co.il': 'mobile'\n};\n\nlet strategy = 'desktop';\ntry {\n  const domain = new URL(url).hostname;\n  for (const [site, strat] of Object.entries(problematicSites)) {\n    if (domain.includes(site)) {\n      strategy = strat;\n      console.log(`Using ${strategy} strategy for ${domain}`);\n      break;\n    }\n  }\n} catch (e) {}\n\n// For mobile strategy, try to convert URL to mobile version\nlet fetchUrl = url;\nif (strategy === 'mobile' && url.includes('ynet.co.il')) {\n  // Some sites have mobile versions that are easier to parse\n  fetchUrl = url.replace('www.ynet', 'm.ynet');\n}\n\nreturn [{\n  json: {\n    url: url,\n    fetchUrl: fetchUrl,\n    strategy: strategy\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4496,
        2064
      ],
      "id": "6c18f521-7435-4922-a92b-7080b480868e",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced HTML Extract - Better for news sites\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconst url = inputData.url || \"\";\n\nconsole.log(\"URL:\", url);\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html || html.length < 100) {\n  console.log(\"No HTML content found\");\n  return [{ \n    json: {\n      error: \"No HTML content received from website\",\n      url: url\n    }\n  }];\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- YNET SPECIFIC: Try structured data first ---\nconsole.log(\"Trying JSON-LD structured data\");\ntry {\n  const jsonLdMatch = html.match(/<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i);\n  if (jsonLdMatch) {\n    const jsonData = JSON.parse(jsonLdMatch[1]);\n    if (jsonData.articleBody) {\n      text = jsonData.articleBody;\n      console.log(\"✅ Found content in JSON-LD\");\n    }\n  }\n} catch (e) {\n  console.log(\"JSON-LD extraction failed:\", e.message);\n}\n\n// --- Try meta description for headline context ---\nlet metaDescription = \"\";\ntry {\n  const metaMatch = html.match(/<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)[\"']/i) ||\n                    html.match(/<meta[^>]*content=[\"']([^\"']+)[\"'][^>]*name=[\"']description[\"']/i);\n  if (metaMatch) {\n    metaDescription = metaMatch[1];\n  }\n} catch (e) {}\n\n// --- Step 1: Try <article> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, \"\")\n        .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*comment[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (text.length > 500) {\n        console.log(\"✅ Found content in <article>\");\n      } else {\n        text = \"\";\n      }\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 2: Try <main> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <main> tag\");\n  const mainMatch = html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n  if (mainMatch) {\n    const extracted = mainMatch[1]\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n      .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n      .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n      .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n      .replace(/<[^>]+>/g, \" \")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    if (extracted.length > text.length) {\n      text = extracted;\n      console.log(\"✅ Found content in <main>\");\n    }\n  }\n}\n\n// --- Step 3: Try common Israeli news site patterns ---\nif (text.length < 500) {\n  console.log(\"Trying Israeli news site patterns\");\n  const contentPatterns = [\n    // Ynet specific\n    /<div[^>]*class=\"[^\"]*art_body[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*article_text[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*text_block[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    // Generic patterns\n    /<div[^>]*class=\"[^\"]*(?:article-body|post-content|entry-content|main-content|article-content|article__content|post-body|content-body|story-body)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*id=\"[^\"]*(?:article|content|main|post|story)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i\n  ];\n  \n  for (const pattern of contentPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      const extracted = match[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*(?:ad|banner|social|share|comment)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (extracted.length > text.length && extracted.length > 500) {\n        text = extracted;\n        console.log(\"✅ Found content in news site pattern\");\n        break;\n      }\n    }\n  }\n}\n\n// --- Step 4: Aggressive paragraph extraction ---\nif (text.length < 500) {\n  console.log(\"Trying aggressive paragraph extraction\");\n  try {\n    // Get all paragraphs\n    const matches = html.match(/<p[^>]*>(.*?)<\\/p>/gis);\n    if (matches && matches.length > 5) {\n      const paragraphs = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => {\n          const lowerText = t.toLowerCase();\n          return t.length > 50 && \n                 !lowerText.includes('cookie') &&\n                 !lowerText.includes('פרטיות') &&\n                 !lowerText.includes('privacy') &&\n                 !lowerText.includes('תנאי שימוש') &&\n                 !lowerText.includes('הרשמה') &&\n                 !lowerText.includes('subscribe') &&\n                 !lowerText.includes('newsletter');\n        });\n      \n      if (paragraphs.length >= 5) {\n        // Add meta description as headline if available\n        text = (metaDescription ? metaDescription + \"\\n\\n\" : \"\") + paragraphs.join(\"\\n\\n\");\n        console.log(\"✅ Found content in paragraphs\");\n      }\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 5: Check for JavaScript-rendered content indicators ---\nif (text.length < 500) {\n  console.log(\"⚠️ Checking for JS-heavy site indicators\");\n  \n  const jsIndicators = [\n    'window.__INITIAL_STATE__',\n    'window.__PRELOADED_STATE__',\n    'data-react-root',\n    'id=\"__next\"',\n    'id=\"root\"',\n    /__NUXT__/,\n    /window\\.__APOLLO_STATE__/\n  ];\n  \n  const hasJsIndicators = jsIndicators.some(indicator => {\n    if (typeof indicator === 'string') {\n      return html.includes(indicator);\n    }\n    return indicator.test(html);\n  });\n  \n  if (hasJsIndicators) {\n    return [{ \n      json: {\n        error: \"This site uses heavy JavaScript rendering. Content cannot be extracted without a browser.\",\n        url: url,\n        suggestion: \"Try sharing a direct link to the article text or PDF version\"\n      }\n    }];\n  }\n}\n\n// --- Step 6: Clean extracted text ---\nif (text.length > 0) {\n  text = text\n    // Remove author bios\n    .replace(/is a (writer|journalist|author|reporter|editor).*?(\\.|$)/gi, \"\")\n    .replace(/writes? (about|for|on).*?(\\.|$)/gi, \"\")\n    .replace(/based in.*?(\\.|$)/gi, \"\")\n    .replace(/כתב(?:ת)? ב.*?(\\.|$)/gi, \"\")\n    // Remove common footer/header text\n    .replace(/all rights reserved/gi, \"\")\n    .replace(/כל הזכויות שמורות/gi, \"\")\n    .replace(/copyright \\d{4}/gi, \"\")\n    .replace(/©\\s*\\d{4}/gi, \"\")\n    // Remove social media prompts\n    .replace(/follow us on.*/gi, \"\")\n    .replace(/עקבו אחרינו.*/gi, \"\")\n    // Clean whitespace\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\n// --- Final validation ---\nif (!text || text.length < 300) {\n  console.log(\"❌ Article body not found or too short\");\n  \n  // Provide specific error message\n  let errorDetail = \"Could not extract article text. \";\n  \n  if (html.includes('נדרשת הרשמה') || html.includes('subscription required')) {\n    errorDetail += \"Site requires subscription or login.\";\n  } else if (html.length < 5000) {\n    errorDetail += \"Page content too small - might be blocked or redirected.\";\n  } else {\n    errorDetail += \"Site may use JavaScript rendering or paywall.\";\n  }\n  \n  return [{ \n    json: {\n      error: errorDetail,\n      url: url,\n      htmlLength: html.length,\n      extractedLength: text.length\n    }\n  }];\n}\n\nconsole.log(`✅ Successfully extracted ${text.length} characters`);\nconsole.log(\"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn [{ \n  json: {\n    article: text, \n    url: url,\n    originalLength: html.length, \n    extractedLength: text.length \n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3968,
        2064
      ],
      "id": "16311c6e-713b-477e-9323-0f7fe6925fb9",
      "name": "HTML Extract"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "5e3db3e5-dc18-47c5-9c94-1086878f8f31",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3744,
        2064
      ],
      "id": "925b2b7a-f495-49bd-b9bb-a9e291fa98b6",
      "name": "Check Extract Error"
    },
    {
      "parameters": {
        "jsCode": "// OPTIMIZED Chunker - Much smaller chunks for local LLM\nconsole.log(\"Chunker input article length:\", $json.article?.length || 0);\n\nconst CHUNK_SIZE = 3000;    // Reduced from 10000 to 3000\nconst OVERLAP = 100;         // Reduced from 150 to 100\nconst MAX_CHUNKS = 1;        // Process only FIRST chunk for speed\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\n// Take only the first meaningful chunk (usually has the main content)\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ \n    json: { \n      url, \n      chunk: text.slice(i, i + CHUNK_SIZE), \n      index: chunks.length + 1 \n    } \n  });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Chunk size:\", chunks[0]?.json.chunk.length);\nreturn chunks;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3072,
        2080
      ],
      "id": "7a4c2077-b3d2-43b0-8adf-844f4df4c143",
      "name": "Chunker",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// IMPROVED Language Detector Node\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count characters for each language\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\n\nconst cyrillicMatches = text.match(/[\\u0400-\\u04FF]/g) || [];\nconst cyrillicChars = cyrillicMatches.length;\n\nconst latinMatches = text.match(/[a-zA-Z]/g) || [];\nconst latinChars = latinMatches.length;\n\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\nconst cyrillicRatio = cyrillicChars / totalChars;\nconst latinRatio = latinChars / totalChars;\n\n// Detect language with better logic\nlet language = \"en\";\nif (hebrewRatio > 0.15 && totalChars > 200) {\n  language = \"he\";\n} else if (cyrillicRatio > 0.15 && totalChars > 200) {\n  language = \"ru\";  // Proper Russian support\n} else if (latinRatio > 0.3) {\n  language = \"en\";\n}\n\nconsole.log(`Language detected: ${language} (He: ${hebrewRatio.toFixed(2)}, Ru: ${cyrillicRatio.toFixed(2)}, En: ${latinRatio.toFixed(2)})`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2816,
        2080
      ],
      "id": "e540abf5-a4af-4cd5-9c3d-1645ae5df815",
      "name": "Language Detector"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1808,
        2080
      ],
      "id": "f209201b-26eb-4715-876a-e7bf4f239617",
      "name": "Debug logger",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// ENHANCED Validator with Better Bullet Filtering\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => {\n      // Filter out empty and \"no details\" bullets\n      if (!b || b.length < 30) return false;\n      \n      const lower = b.toLowerCase();\n      \n      // Filter English \"no details\"\n      if (lower.includes(\"no further details\") || \n          lower.includes(\"no additional details\") ||\n          lower.includes(\"no more details\") ||\n          lower === \"no further details available\" ||\n          lower === \"no further details available.\") {\n        return false;\n      }\n      \n      // Filter Hebrew \"no details\"\n      if (lower.includes(\"לא נמצאו פרטים\") || \n          lower.includes(\"אין פרטים\") ||\n          lower.includes(\"לא נמצא מידע\")) {\n        return false;\n      }\n      \n      // Filter Russian \"no details\"\n      if (lower.includes(\"дополнительная информация недоступна\") ||\n          lower.includes(\"нет дополнительных деталей\") ||\n          lower.includes(\"информация недоступна\")) {\n        return false;\n      }\n      \n      return true;\n    });\n}\n\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\nconsole.log(\"Raw content length:\", raw.length);\n\n// Clean markdown code blocks and extract JSON\nlet s = raw;\n\ns = s.replace(/```json\\s*/gi, \"\");\ns = s.replace(/```\\s*/g, \"\");\n\nconst startIdx = s.indexOf('{');\nif (startIdx > -1) {\n  s = s.substring(startIdx);\n}\n\nconst endIdx = s.lastIndexOf('}');\nif (endIdx > -1) {\n  s = s.substring(0, endIdx + 1);\n}\n\ns = s.replace(/[\\r\\n]+/g, \" \")\n     .replace(/[\\u2018\\u2019]/g, \"'\")\n     .replace(/[\\u201C\\u201D]/g, '\"')\n     .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n  console.log(\"Successfully parsed JSON:\", obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n  \n  // Regex salvage attempt\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    console.log(\"Extracted via regex - title:\", title, \"bullets count:\", bullets.length);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language\n    }\n  }];\n}\n\n// Success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\nconsole.log(\"Extracted title:\", title);\nconsole.log(\"Extracted bullets count:\", bullets.length);\n\n// Clean bullets and filter out \"no details\" messages\nbullets = cleanBullets(bullets, language);\n\nconsole.log(\"After cleaning, bullets count:\", bullets.length);\n\n// IMPORTANT: Don't add default bullets if we have at least 3 good bullets\n// Just return what we have - quality over quantity\nif (bullets.length === 0) {\n  return [{\n    json: {\n      error: \"No valid bullet points generated\",\n      url: $json.url || null,\n      language: language\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,  // Return only real bullets, no padding\n    url: $json.url || null,\n    language: language,\n    source: $json.source || \"Local\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1520,
        2080
      ],
      "id": "2c127a13-1aca-4faa-8534-efa579f84ca7",
      "name": "Validator"
    },
    {
      "parameters": {
        "jsCode": "// ENHANCED Formatter - Handle Any Number of Bullets\nconst { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// Error handling\nif (error) {\n  const errorMessages = {\n    he: \"שגיאה בעיבוד המאמר\",\n    ru: \"Ошибка обработки статьи\",\n    en: \"Error processing article\"\n  };\n  \n  const sourceText = {\n    he: \"מקור:\",\n    ru: \"Источник:\",\n    en: \"Source:\"\n  };\n  \n  const errorMsg = errorMessages[language] || errorMessages.en;\n  const source = sourceText[language] || sourceText.en;\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${source} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : language === \"ru\" ? \"Неизвестно\" : \"Unknown\")}`\n    }\n  }];\n}\n\n// Clean title\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .replace(/^תקציר[:\\s]+/i, \"\")\n  .replace(/^סיכום[:\\s]+/i, \"\")\n  .replace(/^резюме[:\\s]+/i, \"\")\n  .replace(/^краткое содержание[:\\s]+/i, \"\")\n  .replace(/^summary[:\\s]+/i, \"\")\n  .trim();\n\n// Clean bullets - NO DEFAULT PADDING\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    if (!b || b.length < 30) return false;\n    \n    const lower = b.toLowerCase();\n    \n    // Filter out \"no details\" in all languages\n    if (lower.includes(\"no further details\") || \n        lower.includes(\"no additional details\") ||\n        lower.includes(\"לא נמצאו פרטים\") ||\n        lower.includes(\"אין פרטים\") ||\n        lower.includes(\"дополнительная информация недоступна\") ||\n        lower.includes(\"нет дополнительных деталей\")) {\n      return false;\n    }\n    \n    return true;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean);\n\nconsole.log(`Formatted ${cleanBullets.length} bullets for ${language}`);\n\n// If no bullets, return error\nif (cleanBullets.length === 0) {\n  const noContentMsg = {\n    he: \"לא הצלחתי לחלץ מידע מהמאמר\",\n    ru: \"Не удалось извлечь информацию из статьи\",\n    en: \"Could not extract information from article\"\n  };\n  \n  return [{\n    json: {\n      text: `⚠️ ${noContentMsg[language] || noContentMsg.en}\\n\\n${url ? `<${url}|${url}>` : \"\"}`\n    }\n  }];\n}\n\n// Track metrics\nconst metrics = $getWorkflowStaticData('global').metrics || { total: 0, success: 0 };\nmetrics.total++;\nmetrics.success++;\n$getWorkflowStaticData('global').metrics = metrics;\nconsole.log(`Success rate: ${(metrics.success/metrics.total*100).toFixed(1)}%`);\n\n// Build Slack message with proper formatting\nconst RLM = \"\\u200F\"; // Right-to-Left Mark\nconst LRM = \"\\u200E\"; // Left-to-Right Mark\n\n// Helper function to wrap English/numbers in RTL text\nfunction wrapLatin(text) {\n  return text.replace(/([A-Za-z0-9]+(?:[.,:/\\-][A-Za-z0-9]+)*)/g, `${LRM}$1${LRM}`);\n}\n\nif (language === \"he\") {\n  // Hebrew formatting\n  const wrappedTitle = wrapLatin(cleanTitle);\n  const titleLine = url \n    ? `${RLM}:brain: <${url}|${wrappedTitle}>` \n    : `${RLM}:brain: ${wrappedTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => {\n    const wrappedBullet = wrapLatin(b);\n    return `${RLM}• ${wrappedBullet}`;\n  });\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines].join(\"\\n\")\n    } \n  }];\n  \n} else if (language === \"ru\") {\n  // Russian formatting\n  const titleLine = url \n    ? `:brain: <${url}|${cleanTitle}>` \n    : `:brain: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  // English formatting\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines].join(\"\\n\")\n    } \n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1264,
        2080
      ],
      "id": "accebb3d-ae68-421e-9084-137e6182f0ad",
      "name": "Formatter"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -1952,
        2416
      ],
      "id": "f0fc3230-24c1-4470-a13b-1c179a31c6da",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "4Pq4yknedqPByh95",
          "name": "Google Gemini"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "qwen/qwen3-coder-30b",
          "mode": "list",
          "cachedResultName": "qwen/qwen3-coder-30b"
        },
        "options": {
          "frequencyPenalty": 0.3,
          "maxTokens": 2500,
          "presencePenalty": 0.1,
          "temperature": 0.2,
          "timeout": 120000,
          "topP": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2352,
        2336
      ],
      "id": "6740d990-3e6e-4dfd-8a5b-0e7e4c7ef4a9",
      "name": "AI",
      "credentials": {
        "openAiApi": {
          "id": "WJsCuec8UzGRGVIc",
          "name": "Macbook ProM1 Pro"
        }
      }
    }
  ],
  "connections": {
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Error Message1": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Debug logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicate": {
      "main": [
        [
          {
            "node": "Send Duplicate Notice",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check URL Verification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Duplicate Notice": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "Check Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check URL Verification": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "Check Extract Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Extract Error": {
      "main": [
        [
          {
            "node": "Format Error Message1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Language Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        []
      ]
    },
    "AI": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Asia/Jerusalem",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true
  },
  "staticData": {
    "global": {
      "metrics": {
        "total": 200,
        "success": 200
      },
      "processedUrls": {
        "https://gizmodo.com/razer-wants-to-sell-you-a-1337-gaming-mouse-2000718577": 1770387224487,
        "https://gizmodo.com/samsung-870-evo-1tb-ssd-crashes-to-a-new-low-at-0-15-per-gb-in-the-first-major-price-cut-of-the-year-2000718847": 1770387581751,
        "https://news.walla.co.il/item/3814603": 1770387989315,
        "https://e.walla.co.il/item/3811672": 1770392789160,
        "https://gizmodo.com/xikipedia-wants-to-take-the-doom-out-of-doomscrolling-2000718582": 1770392924513,
        "https://gizmodo.com/asus-zenbook-duo-review-a-stacked-laptop-in-more-ways-than-one-2000713558": 1770392980986,
        "https://gizmodo.com/apples-creator-studio-review-best-case-to-bury-your-adobe-subscription-2000714651": 1770393010240,
        "https://www.newsru.co.il/israel/5feb2026/netanyahu508.html": 1770395003435,
        "https://gizmodo.com/you-couldnt-afford-nvidias-next-gen-gpus-even-if-you-wanted-them-2000718884": 1770395587545,
        "https://www.newsru.co.il/world/6feb2026/min_ru_122.html": 1770396110239,
        "https://www.howtogeek.com/this-linux-tool-boosted-my-developer-productivity/": 1770413268686,
        "https://gizmodo.com/finally-ive-found-the-perfect-switch-2-controller-2000718700": 1770487078825,
        "https://news.walla.co.il/item/3814837": 1770487127054,
        "https://sports.walla.co.il/item/3814799": 1770487163669,
        "https://gizmodo.com/why-people-think-jeffrey-epstein-is-alive-and-playing-fortnite-2000718952": 1770487362836,
        "https://news.walla.co.il/item/3814883": 1770556460300
      },
      "processedEvents": {
        "1762243942.321019-undefined": 1762243945452
      },
      "processedMessages": {
        "U08AYDL2FQD_1770387222.599279": 1770387224487,
        "U08AYDL2FQD_1770387580.531059": 1770387581751,
        "U08AYDL2FQD_1770387986.937159": 1770387989315,
        "U08AYDL2FQD_1770392787.038259": 1770392789160,
        "U08AYDL2FQD_1770392922.596009": 1770392924513,
        "U08AYDL2FQD_1770392979.744129": 1770392980986,
        "U08AYDL2FQD_1770393009.165949": 1770393010240,
        "U08AYDL2FQD_1770395001.151739": 1770395003435,
        "U08AYDL2FQD_1770395585.987589": 1770395587545,
        "U08AYDL2FQD_1770396109.102799": 1770396110239,
        "U08AYDL2FQD_1770413265.657809": 1770413268686,
        "U08AYDL2FQD_1770487077.510699": 1770487078825,
        "U08AYDL2FQD_1770487125.234059": 1770487127054,
        "U08AYDL2FQD_1770487161.631269": 1770487163669,
        "U08AYDL2FQD_1770487360.896519": 1770487362836,
        "U08AYDL2FQD_1770556458.604659": 1770556460300
      }
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "c4af3703-2955-43c1-852a-aed1b5295dc0",
  "activeVersionId": "c4af3703-2955-43c1-852a-aed1b5295dc0",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-10-31T09:14:00.820Z",
      "createdAt": "2025-10-31T09:14:00.820Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "pWTWmuHnmIHw48U9"
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-07T17:57:42.000Z",
    "createdAt": "2026-02-07T17:57:40.771Z",
    "versionId": "c4af3703-2955-43c1-852a-aed1b5295dc0",
    "workflowId": "GzAlS0kt9q4YI0n7",
    "nodes": [
      {
        "parameters": {
          "model": "openai/gpt-5-nano",
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
        "typeVersion": 1,
        "position": [
          -2240,
          2336
        ],
        "id": "985b839a-8232-4a4b-b907-0afaab717095",
        "name": "OpenRouter Chat Model",
        "credentials": {
          "openRouterApi": {
            "id": "hGAnvpSAhWRbFktq",
            "name": "OpenRouter account"
          }
        }
      },
      {
        "parameters": {
          "options": {
            "responseCode": 200
          }
        },
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.4,
        "position": [
          -2624,
          1728
        ],
        "id": "6adf1c7c-ba60-4c68-a3da-45b70b1bf2c8",
        "name": "Respond to Webhook1"
      },
      {
        "parameters": {
          "url": "={{$json.fetchUrl}}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "User-Agent",
                "value": "=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
              }
            ]
          },
          "options": {
            "timeout": 10000
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -4192,
          2064
        ],
        "id": "b533795f-6961-4f1f-82fd-1bf0b825d7d9",
        "name": "HTTP Request1",
        "retryOnFail": false,
        "executeOnce": false,
        "alwaysOutputData": false
      },
      {
        "parameters": {
          "jsCode": "// Format Error Message - FIXED\nconst error = $json.error || \"Unknown error\";\nconst url = $json.url || $input.first()?.json?.url || 'Unknown URL';\nconst language = $json.language || 'en';\n\nconsole.log(\"Error formatting - URL:\", url, \"Error:\", error);\n\nconst errorMessages = {\n  he: '⚠️ נכשל בסיכום המאמר',\n  ru: '⚠️ Не удалось обобщить статью',\n  en: '⚠️ Failed to summarize article'\n};\n\nconst reasonText = {\n  he: 'סיבה:',\n  ru: 'Причина:',\n  en: 'Reason:'\n};\n\nconst sourceText = {\n  he: 'מקור:',\n  ru: 'Источник:',\n  en: 'Source:'\n};\n\nconst errorMsg = errorMessages[language] || errorMessages.en;\nconst reason = reasonText[language] || reasonText.en;\nconst source = sourceText[language] || sourceText.en;\n\nreturn [{\n  json: {\n    text: `${errorMsg}\\n${reason} ${error}\\n\\n${source} <${url}|${url}>`\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2144,
          1824
        ],
        "id": "f104fe36-062b-45b7-ba4d-f38226e50792",
        "name": "Format Error Message1"
      },
      {
        "parameters": {
          "amount": 2
        },
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -2608,
          2080
        ],
        "id": "ef611f4b-3a5d-4870-8569-5a7aa49eb6de",
        "name": "Wait1",
        "webhookId": "10236448-b9ab-466e-b2f5-cbe1633592d1"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=You are a summarization tool.\n\nSummarize the following text in {{$json[\"language\"]}}.\n- If \"he\" → write the title and bullets in Hebrew.\n- If \"en\" → write the title and bullets in English.\n\nNever translate — always summarize in the language provided by {{$json[\"language\"]}}.\n\nSummarize into exactly 5 detailed bullet points and a short title.\n\n⚠️ Important:\n- Output must be ONLY valid JSON (no extra text).\n- Always return 5 bullet points.\n- Each bullet should be 40-60 words (3-5 complete sentences).\n- Include specific details: names, dates, numbers, locations, organizations.\n- Provide context and explain why events matter.\n- Write complete sentences with proper grammar.\n- Do NOT include bullet characters (•) in your output.\n- If the text is unclear or empty, still return JSON with a generic title and 5 short placeholders.\n\nFormat:\n{\n  \"title\": \"Short descriptive title (same language)\",\n  \"bullets\": [\n    \"First detailed point with 3-5 complete sentences including names and facts.\",\n    \"Second detailed point with 3-5 complete sentences including context.\",\n    \"Third detailed point with 3-5 complete sentences including background.\",\n    \"Fourth detailed point with 3-5 complete sentences including reactions.\",\n    \"Fifth detailed point with 3-5 complete sentences including implications.\"\n  ]\n}\n\nText:\n{{ $json[\"chunk\"] }}",
          "needsFallback": true,
          "options": {
            "systemMessage": "You are an expert summarization AI. Always output valid JSON only, no markdown."
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 3.1,
        "position": [
          -2320,
          2080
        ],
        "id": "b73a8c93-ee02-497a-9fae-c1ac61bf71a4",
        "name": "AI Agent"
      },
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "slack-events",
          "responseMode": "responseNode",
          "options": {}
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2.1,
        "position": [
          -4144,
          1744
        ],
        "id": "624fbe05-78dc-4c16-b301-f6c7085dbeff",
        "name": "Webhook",
        "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "a8b1824d-7f4a-44b2-9117-e9ffce906f69",
                "leftValue": "={{ $json.isDuplicate }}",
                "rightValue": "true",
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          -3744,
          1408
        ],
        "id": "6ad70a29-e025-49d8-bf2b-5c73d92dbed5",
        "name": "Check Duplicate"
      },
      {
        "parameters": {
          "select": "channel",
          "channelId": {
            "__rl": true,
            "value": "C09BFKKCMQ8",
            "mode": "list",
            "cachedResultName": "n8n-sammarize"
          },
          "text": "={{$json[\"text\"]}}",
          "otherOptions": {}
        },
        "type": "n8n-nodes-base.slack",
        "typeVersion": 2.3,
        "position": [
          -2544,
          1392
        ],
        "id": "a260db80-7643-49aa-b5cd-138488573e29",
        "name": "Send Duplicate Notice",
        "webhookId": "214e8692-2d7d-4ade-9ec1-77708747f604",
        "credentials": {
          "slackApi": {
            "id": "I5astSkOODZZU76Y",
            "name": "n8n Summery"
          }
        }
      },
      {
        "parameters": {
          "select": "channel",
          "channelId": {
            "__rl": true,
            "value": "C09BFKKCMQ8",
            "mode": "list",
            "cachedResultName": "n8n-sammarize"
          },
          "text": "={{$json[\"text\"]}}",
          "otherOptions": {
            "includeLinkToWorkflow": "={{ false }}"
          }
        },
        "type": "n8n-nodes-base.slack",
        "typeVersion": 2.3,
        "position": [
          -1456,
          1392
        ],
        "id": "dea2db3a-1164-4226-bd67-a63ee964d163",
        "name": "Send Summary",
        "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
        "executeOnce": false,
        "credentials": {
          "slackApi": {
            "id": "I5astSkOODZZU76Y",
            "name": "n8n Summery"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  let event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event subtype:', event.subtype);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) IMPORTANT: Skip URL unfurl events and other non-user messages\n  const skipSubtypes = [\n    'bot_message',\n    'message_deleted', \n    'channel_join',\n    'channel_leave',\n    'channel_topic',\n    'channel_purpose',\n    'channel_name',\n    'channel_archive',\n    'channel_unarchive',\n    'group_join',\n    'group_leave',\n    'file_share',\n    'file_comment',\n    'file_mention',\n    'pinned_item',\n    'unpinned_item'\n  ];\n  \n  // Skip these subtypes entirely\n  if (event.subtype && skipSubtypes.includes(event.subtype)) {\n    console.log('Skipping non-user message subtype:', event.subtype);\n    return null;\n  }\n\n  // 4) Handle message_changed events specially\n  if (event.subtype === 'message_changed') {\n    // Check if this is just a URL unfurl update\n    if (event.message && event.previous_message) {\n      const prevText = event.previous_message.text || '';\n      const newText = event.message.text || '';\n      \n      // If text is the same, it's likely just an unfurl update\n      if (prevText === newText) {\n        console.log('Skipping message_changed with same text (likely unfurl)');\n        return null;\n      }\n      \n      // Check if attachments were added (another sign of unfurl)\n      if (!event.previous_message.attachments && event.message.attachments) {\n        console.log('Skipping message_changed with new attachments (likely unfurl)');\n        return null;\n      }\n    }\n    \n    // Use the edited message content\n    event = event.message;\n  }\n\n  // 5) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 6) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 7) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 8) URL EXTRACTION\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Extract URLs using various patterns\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate URLs\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  // 9) ENHANCED DEDUPLICATION\n  let isDuplicateUrl = false;\n  \n  try {\n    const staticData = $getWorkflowStaticData('global');\n    \n    // Initialize storage\n    if (!staticData.processedUrls) {\n      staticData.processedUrls = {};\n    }\n    \n    if (!staticData.processedMessages) {\n      staticData.processedMessages = {};\n    }\n    \n    // Create unique message key using timestamp and user\n    // This is more reliable than event_id which can change\n    const messageKey = `${event.user}_${event.ts}`;\n    \n    // Check if we've seen this exact message before\n    if (staticData.processedMessages[messageKey]) {\n      console.log('DUPLICATE MESSAGE DETECTED:', messageKey);\n      return null;\n    }\n    \n    // Mark message as processed\n    staticData.processedMessages[messageKey] = Date.now();\n    \n    // Check URL deduplication (4 hours window)\n    const fourHoursAgo = Date.now() - 14400000;\n    const lastProcessed = staticData.processedUrls[firstUrl];\n    \n    if (lastProcessed && lastProcessed > fourHoursAgo) {\n      console.log('DUPLICATE URL within 4 hours:', firstUrl);\n      console.log('Last processed:', new Date(lastProcessed).toISOString());\n      isDuplicateUrl = true;\n    } else {\n      // Mark URL as processed\n      staticData.processedUrls[firstUrl] = Date.now();\n      console.log('URL marked as processed:', firstUrl);\n    }\n    \n    // Clean old entries (keep last 2 days)\n    const twoDaysAgo = Date.now() - 172800000;\n    \n    // Clean old URLs\n    Object.keys(staticData.processedUrls).forEach(url => {\n      if (staticData.processedUrls[url] < twoDaysAgo) {\n        delete staticData.processedUrls[url];\n      }\n    });\n    \n    // Clean old messages\n    Object.keys(staticData.processedMessages).forEach(msgKey => {\n      if (staticData.processedMessages[msgKey] < twoDaysAgo) {\n        delete staticData.processedMessages[msgKey];\n      }\n    });\n    \n    // Log cache status\n    console.log('Cache status:', {\n      urls: Object.keys(staticData.processedUrls).length,\n      messages: Object.keys(staticData.processedMessages).length\n    });\n    \n  } catch (e) {\n    console.log('Error in deduplication:', e.message);\n  }\n  \n  // Handle duplicate URLs\n  if (isDuplicateUrl) {\n    return {\n      json: {\n        isDuplicate: true,\n        text: `ℹ️ This URL was already summarized recently.\\n\\n<${firstUrl}|${firstUrl}>`,\n        slack_channel: event.channel,\n        slack_user: event.user,\n        slack_ts: event.ts,\n        slack_thread_ts: event.thread_ts\n      },\n      pairedItem: { item: index }\n    };\n  }\n  \n  // Return data for processing\n  return {\n    json: {\n      isDuplicate: false,\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user, \n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3904,
          1744
        ],
        "id": "e050967c-5da5-4a76-afae-97e4cbdf6c6b",
        "name": "Extract Slack URL",
        "executeOnce": false
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
                "leftValue": "={{$json[\"body\"][\"type\"]}}",
                "rightValue": "url_verification",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          -3568,
          1744
        ],
        "id": "196c147f-a75c-4d8d-b8d1-f9e59675a08a",
        "name": "Check URL Verification"
      },
      {
        "parameters": {
          "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2880,
          1728
        ],
        "id": "abe42212-582d-4764-a676-7c30f27f4539",
        "name": "Return Slack Challenge"
      },
      {
        "parameters": {
          "jsCode": "// Pre-fetch URL Checker\nconst url = $json.url;\n\n// Check if URL is from known problematic sites\nconst problematicSites = {\n  'ynet.co.il': 'mobile',\n  'mako.co.il': 'mobile',\n  'walla.co.il': 'mobile'\n};\n\nlet strategy = 'desktop';\ntry {\n  const domain = new URL(url).hostname;\n  for (const [site, strat] of Object.entries(problematicSites)) {\n    if (domain.includes(site)) {\n      strategy = strat;\n      console.log(`Using ${strategy} strategy for ${domain}`);\n      break;\n    }\n  }\n} catch (e) {}\n\n// For mobile strategy, try to convert URL to mobile version\nlet fetchUrl = url;\nif (strategy === 'mobile' && url.includes('ynet.co.il')) {\n  // Some sites have mobile versions that are easier to parse\n  fetchUrl = url.replace('www.ynet', 'm.ynet');\n}\n\nreturn [{\n  json: {\n    url: url,\n    fetchUrl: fetchUrl,\n    strategy: strategy\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4496,
          2064
        ],
        "id": "6c18f521-7435-4922-a92b-7080b480868e",
        "name": "Code in JavaScript"
      },
      {
        "parameters": {
          "jsCode": "// Enhanced HTML Extract - Better for news sites\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconst url = inputData.url || \"\";\n\nconsole.log(\"URL:\", url);\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html || html.length < 100) {\n  console.log(\"No HTML content found\");\n  return [{ \n    json: {\n      error: \"No HTML content received from website\",\n      url: url\n    }\n  }];\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- YNET SPECIFIC: Try structured data first ---\nconsole.log(\"Trying JSON-LD structured data\");\ntry {\n  const jsonLdMatch = html.match(/<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i);\n  if (jsonLdMatch) {\n    const jsonData = JSON.parse(jsonLdMatch[1]);\n    if (jsonData.articleBody) {\n      text = jsonData.articleBody;\n      console.log(\"✅ Found content in JSON-LD\");\n    }\n  }\n} catch (e) {\n  console.log(\"JSON-LD extraction failed:\", e.message);\n}\n\n// --- Try meta description for headline context ---\nlet metaDescription = \"\";\ntry {\n  const metaMatch = html.match(/<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)[\"']/i) ||\n                    html.match(/<meta[^>]*content=[\"']([^\"']+)[\"'][^>]*name=[\"']description[\"']/i);\n  if (metaMatch) {\n    metaDescription = metaMatch[1];\n  }\n} catch (e) {}\n\n// --- Step 1: Try <article> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, \"\")\n        .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*comment[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (text.length > 500) {\n        console.log(\"✅ Found content in <article>\");\n      } else {\n        text = \"\";\n      }\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 2: Try <main> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <main> tag\");\n  const mainMatch = html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n  if (mainMatch) {\n    const extracted = mainMatch[1]\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n      .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n      .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n      .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n      .replace(/<[^>]+>/g, \" \")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    if (extracted.length > text.length) {\n      text = extracted;\n      console.log(\"✅ Found content in <main>\");\n    }\n  }\n}\n\n// --- Step 3: Try common Israeli news site patterns ---\nif (text.length < 500) {\n  console.log(\"Trying Israeli news site patterns\");\n  const contentPatterns = [\n    // Ynet specific\n    /<div[^>]*class=\"[^\"]*art_body[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*article_text[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*text_block[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    // Generic patterns\n    /<div[^>]*class=\"[^\"]*(?:article-body|post-content|entry-content|main-content|article-content|article__content|post-body|content-body|story-body)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*id=\"[^\"]*(?:article|content|main|post|story)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i\n  ];\n  \n  for (const pattern of contentPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      const extracted = match[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*(?:ad|banner|social|share|comment)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (extracted.length > text.length && extracted.length > 500) {\n        text = extracted;\n        console.log(\"✅ Found content in news site pattern\");\n        break;\n      }\n    }\n  }\n}\n\n// --- Step 4: Aggressive paragraph extraction ---\nif (text.length < 500) {\n  console.log(\"Trying aggressive paragraph extraction\");\n  try {\n    // Get all paragraphs\n    const matches = html.match(/<p[^>]*>(.*?)<\\/p>/gis);\n    if (matches && matches.length > 5) {\n      const paragraphs = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => {\n          const lowerText = t.toLowerCase();\n          return t.length > 50 && \n                 !lowerText.includes('cookie') &&\n                 !lowerText.includes('פרטיות') &&\n                 !lowerText.includes('privacy') &&\n                 !lowerText.includes('תנאי שימוש') &&\n                 !lowerText.includes('הרשמה') &&\n                 !lowerText.includes('subscribe') &&\n                 !lowerText.includes('newsletter');\n        });\n      \n      if (paragraphs.length >= 5) {\n        // Add meta description as headline if available\n        text = (metaDescription ? metaDescription + \"\\n\\n\" : \"\") + paragraphs.join(\"\\n\\n\");\n        console.log(\"✅ Found content in paragraphs\");\n      }\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 5: Check for JavaScript-rendered content indicators ---\nif (text.length < 500) {\n  console.log(\"⚠️ Checking for JS-heavy site indicators\");\n  \n  const jsIndicators = [\n    'window.__INITIAL_STATE__',\n    'window.__PRELOADED_STATE__',\n    'data-react-root',\n    'id=\"__next\"',\n    'id=\"root\"',\n    /__NUXT__/,\n    /window\\.__APOLLO_STATE__/\n  ];\n  \n  const hasJsIndicators = jsIndicators.some(indicator => {\n    if (typeof indicator === 'string') {\n      return html.includes(indicator);\n    }\n    return indicator.test(html);\n  });\n  \n  if (hasJsIndicators) {\n    return [{ \n      json: {\n        error: \"This site uses heavy JavaScript rendering. Content cannot be extracted without a browser.\",\n        url: url,\n        suggestion: \"Try sharing a direct link to the article text or PDF version\"\n      }\n    }];\n  }\n}\n\n// --- Step 6: Clean extracted text ---\nif (text.length > 0) {\n  text = text\n    // Remove author bios\n    .replace(/is a (writer|journalist|author|reporter|editor).*?(\\.|$)/gi, \"\")\n    .replace(/writes? (about|for|on).*?(\\.|$)/gi, \"\")\n    .replace(/based in.*?(\\.|$)/gi, \"\")\n    .replace(/כתב(?:ת)? ב.*?(\\.|$)/gi, \"\")\n    // Remove common footer/header text\n    .replace(/all rights reserved/gi, \"\")\n    .replace(/כל הזכויות שמורות/gi, \"\")\n    .replace(/copyright \\d{4}/gi, \"\")\n    .replace(/©\\s*\\d{4}/gi, \"\")\n    // Remove social media prompts\n    .replace(/follow us on.*/gi, \"\")\n    .replace(/עקבו אחרינו.*/gi, \"\")\n    // Clean whitespace\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\n// --- Final validation ---\nif (!text || text.length < 300) {\n  console.log(\"❌ Article body not found or too short\");\n  \n  // Provide specific error message\n  let errorDetail = \"Could not extract article text. \";\n  \n  if (html.includes('נדרשת הרשמה') || html.includes('subscription required')) {\n    errorDetail += \"Site requires subscription or login.\";\n  } else if (html.length < 5000) {\n    errorDetail += \"Page content too small - might be blocked or redirected.\";\n  } else {\n    errorDetail += \"Site may use JavaScript rendering or paywall.\";\n  }\n  \n  return [{ \n    json: {\n      error: errorDetail,\n      url: url,\n      htmlLength: html.length,\n      extractedLength: text.length\n    }\n  }];\n}\n\nconsole.log(`✅ Successfully extracted ${text.length} characters`);\nconsole.log(\"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn [{ \n  json: {\n    article: text, \n    url: url,\n    originalLength: html.length, \n    extractedLength: text.length \n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3968,
          2064
        ],
        "id": "16311c6e-713b-477e-9323-0f7fe6925fb9",
        "name": "HTML Extract"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "5e3db3e5-dc18-47c5-9c94-1086878f8f31",
                "leftValue": "={{ $json.error }}",
                "rightValue": "",
                "operator": {
                  "type": "string",
                  "operation": "notEmpty",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          -3744,
          2064
        ],
        "id": "925b2b7a-f495-49bd-b9bb-a9e291fa98b6",
        "name": "Check Extract Error"
      },
      {
        "parameters": {
          "jsCode": "// OPTIMIZED Chunker - Much smaller chunks for local LLM\nconsole.log(\"Chunker input article length:\", $json.article?.length || 0);\n\nconst CHUNK_SIZE = 3000;    // Reduced from 10000 to 3000\nconst OVERLAP = 100;         // Reduced from 150 to 100\nconst MAX_CHUNKS = 1;        // Process only FIRST chunk for speed\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\n// Take only the first meaningful chunk (usually has the main content)\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ \n    json: { \n      url, \n      chunk: text.slice(i, i + CHUNK_SIZE), \n      index: chunks.length + 1 \n    } \n  });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Chunk size:\", chunks[0]?.json.chunk.length);\nreturn chunks;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3072,
          2080
        ],
        "id": "7a4c2077-b3d2-43b0-8adf-844f4df4c143",
        "name": "Chunker",
        "executeOnce": false
      },
      {
        "parameters": {
          "jsCode": "// IMPROVED Language Detector Node\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count characters for each language\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\n\nconst cyrillicMatches = text.match(/[\\u0400-\\u04FF]/g) || [];\nconst cyrillicChars = cyrillicMatches.length;\n\nconst latinMatches = text.match(/[a-zA-Z]/g) || [];\nconst latinChars = latinMatches.length;\n\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\nconst cyrillicRatio = cyrillicChars / totalChars;\nconst latinRatio = latinChars / totalChars;\n\n// Detect language with better logic\nlet language = \"en\";\nif (hebrewRatio > 0.15 && totalChars > 200) {\n  language = \"he\";\n} else if (cyrillicRatio > 0.15 && totalChars > 200) {\n  language = \"ru\";  // Proper Russian support\n} else if (latinRatio > 0.3) {\n  language = \"en\";\n}\n\nconsole.log(`Language detected: ${language} (He: ${hebrewRatio.toFixed(2)}, Ru: ${cyrillicRatio.toFixed(2)}, En: ${latinRatio.toFixed(2)})`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2816,
          2080
        ],
        "id": "e540abf5-a4af-4cd5-9c3d-1645ae5df815",
        "name": "Language Detector"
      },
      {
        "parameters": {
          "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1808,
          2080
        ],
        "id": "f209201b-26eb-4715-876a-e7bf4f239617",
        "name": "Debug logger",
        "executeOnce": false
      },
      {
        "parameters": {
          "jsCode": "// ENHANCED Validator with Better Bullet Filtering\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => {\n      // Filter out empty and \"no details\" bullets\n      if (!b || b.length < 30) return false;\n      \n      const lower = b.toLowerCase();\n      \n      // Filter English \"no details\"\n      if (lower.includes(\"no further details\") || \n          lower.includes(\"no additional details\") ||\n          lower.includes(\"no more details\") ||\n          lower === \"no further details available\" ||\n          lower === \"no further details available.\") {\n        return false;\n      }\n      \n      // Filter Hebrew \"no details\"\n      if (lower.includes(\"לא נמצאו פרטים\") || \n          lower.includes(\"אין פרטים\") ||\n          lower.includes(\"לא נמצא מידע\")) {\n        return false;\n      }\n      \n      // Filter Russian \"no details\"\n      if (lower.includes(\"дополнительная информация недоступна\") ||\n          lower.includes(\"нет дополнительных деталей\") ||\n          lower.includes(\"информация недоступна\")) {\n        return false;\n      }\n      \n      return true;\n    });\n}\n\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\nconsole.log(\"Raw content length:\", raw.length);\n\n// Clean markdown code blocks and extract JSON\nlet s = raw;\n\ns = s.replace(/```json\\s*/gi, \"\");\ns = s.replace(/```\\s*/g, \"\");\n\nconst startIdx = s.indexOf('{');\nif (startIdx > -1) {\n  s = s.substring(startIdx);\n}\n\nconst endIdx = s.lastIndexOf('}');\nif (endIdx > -1) {\n  s = s.substring(0, endIdx + 1);\n}\n\ns = s.replace(/[\\r\\n]+/g, \" \")\n     .replace(/[\\u2018\\u2019]/g, \"'\")\n     .replace(/[\\u201C\\u201D]/g, '\"')\n     .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n  console.log(\"Successfully parsed JSON:\", obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n  \n  // Regex salvage attempt\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    console.log(\"Extracted via regex - title:\", title, \"bullets count:\", bullets.length);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language\n    }\n  }];\n}\n\n// Success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\nconsole.log(\"Extracted title:\", title);\nconsole.log(\"Extracted bullets count:\", bullets.length);\n\n// Clean bullets and filter out \"no details\" messages\nbullets = cleanBullets(bullets, language);\n\nconsole.log(\"After cleaning, bullets count:\", bullets.length);\n\n// IMPORTANT: Don't add default bullets if we have at least 3 good bullets\n// Just return what we have - quality over quantity\nif (bullets.length === 0) {\n  return [{\n    json: {\n      error: \"No valid bullet points generated\",\n      url: $json.url || null,\n      language: language\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,  // Return only real bullets, no padding\n    url: $json.url || null,\n    language: language,\n    source: $json.source || \"Local\"\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1520,
          2080
        ],
        "id": "2c127a13-1aca-4faa-8534-efa579f84ca7",
        "name": "Validator"
      },
      {
        "parameters": {
          "jsCode": "// ENHANCED Formatter - Handle Any Number of Bullets\nconst { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// Error handling\nif (error) {\n  const errorMessages = {\n    he: \"שגיאה בעיבוד המאמר\",\n    ru: \"Ошибка обработки статьи\",\n    en: \"Error processing article\"\n  };\n  \n  const sourceText = {\n    he: \"מקור:\",\n    ru: \"Источник:\",\n    en: \"Source:\"\n  };\n  \n  const errorMsg = errorMessages[language] || errorMessages.en;\n  const source = sourceText[language] || sourceText.en;\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${source} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : language === \"ru\" ? \"Неизвестно\" : \"Unknown\")}`\n    }\n  }];\n}\n\n// Clean title\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .replace(/^תקציר[:\\s]+/i, \"\")\n  .replace(/^סיכום[:\\s]+/i, \"\")\n  .replace(/^резюме[:\\s]+/i, \"\")\n  .replace(/^краткое содержание[:\\s]+/i, \"\")\n  .replace(/^summary[:\\s]+/i, \"\")\n  .trim();\n\n// Clean bullets - NO DEFAULT PADDING\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    if (!b || b.length < 30) return false;\n    \n    const lower = b.toLowerCase();\n    \n    // Filter out \"no details\" in all languages\n    if (lower.includes(\"no further details\") || \n        lower.includes(\"no additional details\") ||\n        lower.includes(\"לא נמצאו פרטים\") ||\n        lower.includes(\"אין פרטים\") ||\n        lower.includes(\"дополнительная информация недоступна\") ||\n        lower.includes(\"нет дополнительных деталей\")) {\n      return false;\n    }\n    \n    return true;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean);\n\nconsole.log(`Formatted ${cleanBullets.length} bullets for ${language}`);\n\n// If no bullets, return error\nif (cleanBullets.length === 0) {\n  const noContentMsg = {\n    he: \"לא הצלחתי לחלץ מידע מהמאמר\",\n    ru: \"Не удалось извлечь информацию из статьи\",\n    en: \"Could not extract information from article\"\n  };\n  \n  return [{\n    json: {\n      text: `⚠️ ${noContentMsg[language] || noContentMsg.en}\\n\\n${url ? `<${url}|${url}>` : \"\"}`\n    }\n  }];\n}\n\n// Track metrics\nconst metrics = $getWorkflowStaticData('global').metrics || { total: 0, success: 0 };\nmetrics.total++;\nmetrics.success++;\n$getWorkflowStaticData('global').metrics = metrics;\nconsole.log(`Success rate: ${(metrics.success/metrics.total*100).toFixed(1)}%`);\n\n// Build Slack message with proper formatting\nconst RLM = \"\\u200F\"; // Right-to-Left Mark\nconst LRM = \"\\u200E\"; // Left-to-Right Mark\n\n// Helper function to wrap English/numbers in RTL text\nfunction wrapLatin(text) {\n  return text.replace(/([A-Za-z0-9]+(?:[.,:/\\-][A-Za-z0-9]+)*)/g, `${LRM}$1${LRM}`);\n}\n\nif (language === \"he\") {\n  // Hebrew formatting\n  const wrappedTitle = wrapLatin(cleanTitle);\n  const titleLine = url \n    ? `${RLM}:brain: <${url}|${wrappedTitle}>` \n    : `${RLM}:brain: ${wrappedTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => {\n    const wrappedBullet = wrapLatin(b);\n    return `${RLM}• ${wrappedBullet}`;\n  });\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines].join(\"\\n\")\n    } \n  }];\n  \n} else if (language === \"ru\") {\n  // Russian formatting\n  const titleLine = url \n    ? `:brain: <${url}|${cleanTitle}>` \n    : `:brain: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  // English formatting\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines].join(\"\\n\")\n    } \n  }];\n}"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1264,
          2080
        ],
        "id": "accebb3d-ae68-421e-9084-137e6182f0ad",
        "name": "Formatter"
      },
      {
        "parameters": {
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
        "typeVersion": 1,
        "position": [
          -1952,
          2416
        ],
        "id": "f0fc3230-24c1-4470-a13b-1c179a31c6da",
        "name": "Google Gemini Chat Model",
        "credentials": {
          "googlePalmApi": {
            "id": "4Pq4yknedqPByh95",
            "name": "Google Gemini"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "value": "qwen/qwen3-coder-30b",
            "mode": "list",
            "cachedResultName": "qwen/qwen3-coder-30b"
          },
          "options": {
            "frequencyPenalty": 0.3,
            "maxTokens": 2500,
            "presencePenalty": 0.1,
            "temperature": 0.2,
            "timeout": 120000,
            "topP": 0.9
          }
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
        "typeVersion": 1.2,
        "position": [
          -2352,
          2336
        ],
        "id": "6740d990-3e6e-4dfd-8a5b-0e7e4c7ef4a9",
        "name": "AI",
        "credentials": {
          "openAiApi": {
            "id": "WJsCuec8UzGRGVIc",
            "name": "Macbook ProM1 Pro"
          }
        }
      }
    ],
    "connections": {
      "OpenRouter Chat Model": {
        "ai_languageModel": [
          [
            {
              "node": "AI Agent",
              "type": "ai_languageModel",
              "index": 1
            }
          ]
        ]
      },
      "HTTP Request1": {
        "main": [
          [
            {
              "node": "HTML Extract",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Error Message1": {
        "main": [
          [
            {
              "node": "Send Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait1": {
        "main": [
          [
            {
              "node": "AI Agent",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "AI Agent": {
        "main": [
          [
            {
              "node": "Debug logger",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook": {
        "main": [
          [
            {
              "node": "Extract Slack URL",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Duplicate": {
        "main": [
          [
            {
              "node": "Send Duplicate Notice",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Check URL Verification",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Duplicate Notice": {
        "main": [
          [
            {
              "node": "Extract Slack URL",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Slack URL": {
        "main": [
          [
            {
              "node": "Check Duplicate",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check URL Verification": {
        "main": [
          [
            {
              "node": "Return Slack Challenge",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Code in JavaScript",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Return Slack Challenge": {
        "main": [
          [
            {
              "node": "Respond to Webhook1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Code in JavaScript": {
        "main": [
          [
            {
              "node": "HTTP Request1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "HTML Extract": {
        "main": [
          [
            {
              "node": "Check Extract Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Extract Error": {
        "main": [
          [
            {
              "node": "Format Error Message1",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Chunker",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Chunker": {
        "main": [
          [
            {
              "node": "Language Detector",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Language Detector": {
        "main": [
          [
            {
              "node": "Wait1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Debug logger": {
        "main": [
          [
            {
              "node": "Validator",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validator": {
        "main": [
          [
            {
              "node": "Formatter",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Formatter": {
        "main": [
          [
            {
              "node": "Send Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Google Gemini Chat Model": {
        "ai_languageModel": [
          []
        ]
      },
      "AI": {
        "ai_languageModel": [
          [
            {
              "node": "AI Agent",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Alex Vinokur",
    "name": "Version c4af3703",
    "description": "",
    "autosaved": true
  },
  "tags": []
}