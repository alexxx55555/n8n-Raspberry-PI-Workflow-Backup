{
  "createdAt": "2025-09-02T14:14:42.893Z",
  "updatedAt": "2025-09-30T07:55:07.000Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Slack Summary",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -2224,
        -1152
      ],
      "id": "40e6849b-6546-4357-8efe-a52e415168f6",
      "name": "Send a message",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  const event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.subtype === 'bot_message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 4) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 5) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 6) IMPROVED URL EXTRACTION - Works with mobile\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text (mobile often sends encoded URLs)\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Pattern 1: Slack format <http://example.com|label> or <http://example.com>\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  // Pattern 2: URL-encoded Slack format (mobile)\n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  // Pattern 3: Plain URLs\n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  // Pattern 4: Fully encoded URLs\n  const encodedUrlRegex = /https?%3A%2F%2F[^\\s<>\"'()[\\]{}]+/gi;\n  while ((match = encodedUrlRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[0]));\n    } catch (e) {\n      urls.add(match[0]);\n    }\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  return {\n    json: {\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user,\n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4496,
        -1472
      ],
      "id": "d0ea7ac4-1635-4c44-9cc4-584c19a2de28",
      "name": "Extract Slack URL",
      "executeOnce": false
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -3632,
        -1488
      ],
      "id": "33337fef-da3c-4e18-a909-8cf008d8fa6d",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -4160,
        -1472
      ],
      "id": "21b6f324-5afa-4aba-ad6a-77ec10d66718",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3888,
        -1488
      ],
      "id": "68dfb7b4-b700-4c8a-90c6-fa822286d608",
      "name": "Return Slack Challenge"
    },
    {
      "parameters": {
        "jsCode": "// Log input for debugging\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html) {\n  console.log(\"No HTML content found\");\n  return { error: \"No HTML content found\", availableFields: Object.keys(inputData) };\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- Step 1: Try JSON-LD structured data FIRST (best for mobile sites) ---\ntry {\n  const jsonBlocks = html.match(/<script[^>]+type=[\"']application\\/(ld\\+json|json)[\"'][^>]*>([\\s\\S]*?)<\\/script>/gi);\n  if (jsonBlocks) {\n    for (let block of jsonBlocks) {\n      try {\n        const clean = block.replace(/<script[^>]*>/i, \"\").replace(/<\\/script>/i, \"\").trim();\n        const parsed = JSON.parse(clean);\n        \n        // Recursive search for article content\n        function findContent(obj) {\n          if (!obj || typeof obj !== \"object\") return null;\n          if (obj.articleBody && typeof obj.articleBody === \"string\" && obj.articleBody.length > 200) return obj.articleBody;\n          if (obj.text && typeof obj.text === \"string\" && obj.text.length > 200) return obj.text;\n          if (obj.description && typeof obj.description === \"string\" && obj.description.length > 200) return obj.description;\n          \n          for (const key of Object.keys(obj)) {\n            const result = findContent(obj[key]);\n            if (result) return result;\n          }\n          return null;\n        }\n        \n        const result = findContent(parsed);\n        if (result && result.length > 200) {\n          text = result;\n          console.log(\"Found content in JSON-LD\");\n          break;\n        }\n      } catch (err) {\n        console.log(\"JSON parse error:\", err.message);\n      }\n    }\n  }\n} catch (e) {\n  console.log(\"JSON extraction error:\", e.message);\n}\n\n// --- Step 2: Try <article> tag ---\nif (text.length < 200) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      console.log(\"Found content in <article>\");\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 3: Try <p> and heading tags ---\nif (text.length < 200) {\n  console.log(\"Trying <p> and heading tags\");\n  try {\n    const matches = html.match(/<(p|h[1-6])[^>]*>(.*?)<\\/(p|h[1-6])>/gis);\n    if (matches) {\n      text = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => t.length > 20 && !t.match(/\\{|\\}/))  // Filter out CSS/JS\n        .join(\"\\n\\n\");\n      console.log(\"Found content in paragraphs\");\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 4: Check if we got CSS/JS instead of content ---\nconst cssJsIndicators = /\\{[\\s\\S]*?\\}|function\\s*\\(|\\.css|@media|var\\(--/;\nif (cssJsIndicators.test(text)) {\n  console.log(\"Detected CSS/JS code instead of article content\");\n  return { \n    error: \"Mobile site - unable to extract article content (got CSS/JS instead)\", \n    url: inputData.url || \"unknown\"\n  };\n}\n\n// --- Final validation ---\nif (!text || text.length < 200) {\n  console.log(\"Article body not found\");\n  return { \n    error: \"Article body not found (likely JS-rendered mobile site)\", \n    url: inputData.url || \"unknown\"\n  };\n}\n\nconsole.log(\"Extracted text length:\", text.length, \"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn { \n  article: text, \n  url: inputData.url || \"\",\n  originalLength: html.length, \n  extractedLength: text.length \n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4512,
        -1152
      ],
      "id": "fa398ca8-bcb2-4ab5-ac5c-987fa18bd404",
      "name": "HTML Extract"
    },
    {
      "parameters": {
        "jsCode": "// === HELPER FUNCTION - AT TOP ===\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => b && b.length > 20); // Filter short/empty bullets\n}\n\n// Log input\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\n// Get language from input\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\n\n// Aggressive cleaning\nlet s = raw\n  .replace(/```json\\s*/gi, \"\")\n  .replace(/```\\s*/g, \"\")\n  .replace(/\\*Automated with.*$/gim, \"\")\n  .replace(/^[^{]*/, \"\")  // Remove before {\n  .replace(/[^}]*$/, \"\")  // Remove after }\n  .replace(/-/g, \"-\")\n  .replace(/[\\r\\n]+/g, \" \")\n  .replace(/[\\u2018\\u2019]/g, \"'\")\n  .replace(/[\\u201C\\u201D]/g, '\"')\n  .replace(/\\s+/g, \" \")\n  .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n}\n\n// Try regex salvage if parse failed\nif (!obj || typeof obj !== \"object\") {\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,  // ✅ PASS LANGUAGE\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language  // ✅ PASS LANGUAGE\n    }\n  }];\n}\n\n// Normal success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\n// Clean bullets\nbullets = cleanBullets(bullets, language);\n\n// Ensure exactly 5 bullets\nif (bullets.length > 5) bullets = bullets.slice(0, 5);\n\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים.\" \n  : \"No further details available.\";\n\nwhile (bullets.length < 5) {\n  bullets.push(defaultBullet);\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,\n    url: $json.url || null,\n    language: language,  // ✅ PASS LANGUAGE\n    source: $json.source || \"Local\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2944,
        -1152
      ],
      "id": "82f9572e-575b-488e-86af-921c5a4f8825",
      "name": "Validator"
    },
    {
      "parameters": {
        "jsCode": "const { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// --- Error case ---\nif (error) {\n  const errorMsg = language === \"he\" ? \"שגיאה בעיבוד המאמר\" : \"Error processing article\";\n  const sourceText = language === \"he\" ? \"מקור:\" : \"Source:\";\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${sourceText} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : \"Unknown\")}`\n    }\n  }];\n}\n\n// --- Clean title ---\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .trim();\n\n// --- Clean bullets ---\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    // Filter out English default bullets if language is Hebrew\n    if (language === \"he\" && b === \"No further details available.\") {\n      return false;\n    }\n    return b && b.length > 25;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")  // Remove existing bullets\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\n// --- Guarantee 5 bullets with language-appropriate defaults ---\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים בנושא זה\" \n  : \"No further details available\";\n\nwhile (cleanBullets.length < 5) {\n  cleanBullets.push(defaultBullet);\n}\n\n// --- Build Slack message ---\nconst RTL = \"\\u200F\";\n\nif (language === \"he\") {\n  const titleLine = url \n    ? `:brain: סיכום: <${url}|${cleanTitle}>` \n    : `:brain: סיכום: ${cleanTitle}`;\n  \n  // Build message with proper RTL wrapping\n  const bulletLines = cleanBullets.map(b => `${RTL}• ${b}${RTL}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2688,
        -1152
      ],
      "id": "9d9f0861-7c99-4bd4-933f-278b2874e04a",
      "name": "Formatter"
    },
    {
      "parameters": {
        "url": "={{$json[\"url\"]}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4784,
        -1152
      ],
      "id": "9455bb97-07b9-4735-be04-20d086c28215",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert summarization tool that creates accurate, fact-based summaries.\n\nLanguage: {{$json[\"language\"]}}\n- If \"he\" → write everything in Hebrew (עברית)\n- If \"en\" → write everything in English\n\nTASK: Summarize the text into exactly 5 detailed bullet points.\n\nCRITICAL ACCURACY RULES:\n- ONLY use information explicitly stated in the source text\n- NEVER invent, assume, or add names, facts, or details not in the source\n- If a name is mentioned, use it exactly as written in the source\n- If a fact is unclear or missing, do NOT make up details\n- Do NOT add context or background information not present in the text\n- When uncertain, use phrases like \"according to the article\" or \"the text states\"\n\nBULLET POINT REQUIREMENTS:\n- Each bullet must be 3-5 complete sentences (40-60 words)\n- Start each bullet with • (bullet character)\n- Include only specific information found in the source text\n- Provide direct facts, quotes, and statements from the article\n- Write in clear, journalistic style\n- Every sentence must be complete with proper punctuation\n\nOUTPUT RULES:\n- Output ONLY valid JSON\n- NO markdown (no ```), NO extra text\n- Start with { and end with }\n\nRequired format:\n{\"title\":\"Accurate title based on article content\",\"bullets\":[\"• First bullet with facts only from the source text, using exact names and details as they appear in the article.\",\"• Second bullet with verified information directly from the text.\",\"• Third bullet with accurate details from the source material.\",\"• Fourth bullet with factual information from the article.\",\"• Fifth bullet completing the summary with source-based facts.\"]}\n\nText to summarize:\n{{ $json[\"chunk\"] }}\n\nCRITICAL: Only include information explicitly stated in the text above. Do not invent or assume any details.",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -3744,
        -1152
      ],
      "id": "34ca356c-530a-434d-bc6f-d4fe1f6f1b48",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -4736,
        -1472
      ],
      "id": "3e66a8cf-0cd3-40ee-9779-962d9e8840df",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"Chunker input article length:\", $json.article?.length || 0, \"Sample:\", $json.article?.slice(0, 500));\n\nconst CHUNK_SIZE = 2000;   // smaller than before\nconst OVERLAP = 150;\nconst MAX_CHUNKS = 20;\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ json: { url, chunk: text.slice(i, i + CHUNK_SIZE), index: chunks.length + 1 } });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Sample chunk:\", chunks[0]?.json.chunk.slice(0, 500));\nreturn chunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4288,
        -1152
      ],
      "id": "5e498db8-fa13-49c3-a2c0-f6311d007068",
      "name": "Chunker",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3232,
        -1152
      ],
      "id": "67f69db1-b9b7-4500-8309-52267a73facb",
      "name": "Debug logger",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// LANGUAGE DETECTOR NODE\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",  // Default fallback\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count Hebrew characters\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\n\n// Only treat as Hebrew if at least 20% of characters are Hebrew AND total length > 200\nconst language = (hebrewRatio > 0.2 && totalChars > 200) ? \"he\" : \"en\";\n\nconsole.log(`Language detected: ${language}, Hebrew chars: ${hebrewChars}, Ratio: ${hebrewRatio.toFixed(3)}, Total: ${totalChars}`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4080,
        -1152
      ],
      "id": "27b1cbdd-524c-4c44-90bd-714cd8d86c38",
      "name": "Language Detector"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "google/gemma-3-12b",
          "mode": "list",
          "cachedResultName": "google/gemma-3-12b"
        },
        "options": {
          "maxTokens": 1500,
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -3744,
        -880
      ],
      "id": "879a71c2-d1a5-4fe6-96b3-6513cfc7d39a",
      "name": "AI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    }
  ],
  "connections": {
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Debug logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Language Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "7383ab8e-20f0-42dc-bc65-f4f959b0fb8f",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-09-02T14:14:42.897Z",
      "updatedAt": "2025-09-02T14:14:42.897Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "NptNxIUgBjUJaRfd"
    }
  ],
  "tags": []
}