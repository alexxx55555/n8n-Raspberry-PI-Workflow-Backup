{
  "createdAt": "2025-09-02T14:14:42.893Z",
  "updatedAt": "2025-10-09T21:41:14.000Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Automatic Slack Summary",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  const event = body.event || {};\n  const headers = item.json.headers || {};\n\n  console.log('Received event type:', body.type);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null;\n  }\n\n  // 3) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.subtype === 'bot_message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null;\n  }\n\n  // 4) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null;\n  }\n\n  // 5) Skip messages from your bot\n  const BOT_USER_ID = 'U07K8QJ9XYZ';\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null;\n  }\n\n  // 6) IMPROVED URL EXTRACTION - Works with mobile\n  const text = event.text || \"\";\n  const urls = new Set();\n  \n  console.log('Raw message text:', text);\n  \n  // Decode URL-encoded text (mobile often sends encoded URLs)\n  let decodedText = text;\n  try {\n    decodedText = decodeURIComponent(text);\n  } catch (e) {\n    decodedText = text;\n  }\n  \n  // Pattern 1: Slack format <http://example.com|label> or <http://example.com>\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[1]);\n  }\n  \n  // Pattern 2: URL-encoded Slack format (mobile)\n  const encodedSlackRegex = /%3C(https?:\\/\\/[^%>|]+)(%7C[^%>]+)?%3E/gi;\n  while ((match = encodedSlackRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[1]));\n    } catch (e) {\n      urls.add(match[1]);\n    }\n  }\n  \n  // Pattern 3: Plain URLs\n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(decodedText)) !== null) {\n    urls.add(match[0]);\n  }\n  \n  // Pattern 4: Fully encoded URLs\n  const encodedUrlRegex = /https?%3A%2F%2F[^\\s<>\"'()[\\]{}]+/gi;\n  while ((match = encodedUrlRegex.exec(text)) !== null) {\n    try {\n      urls.add(decodeURIComponent(match[0]));\n    } catch (e) {\n      urls.add(match[0]);\n    }\n  }\n  \n  console.log('All URLs found:', Array.from(urls));\n  \n  // Clean and validate\n  const cleanUrls = new Set();\n  for (const url of urls) {\n    let cleanUrl = url.trim().replace(/[.,;:)]+$/, '');\n    if (cleanUrl.match(/^https?:\\/\\/.+\\..+/)) {\n      cleanUrls.add(cleanUrl);\n    }\n  }\n  \n  const firstUrl = Array.from(cleanUrls)[0] || '';\n  \n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null;\n  }\n  \n  console.log('Selected URL:', firstUrl);\n  \n  // 7) DEDUPLICATION - Check URL instead of event_id\n  const staticData = $getWorkflowStaticData('global');\n  \n  if (!staticData.processedUrls) {\n    staticData.processedUrls = {};\n  }\n  \n  const hourAgo = Date.now() - 3600000; // 1 hour\n  \n  // Check if this URL was processed recently\nif (staticData.processedUrls[firstUrl] && staticData.processedUrls[firstUrl] > hourAgo) {\n  console.log('URL already processed recently, sending duplicate notice');\n  return {\n    json: {\n      isDuplicate: true,\n      text: `ℹ️ This URL was already summarized recently.\\n\\n<${firstUrl}|${firstUrl}>`\n    },\n    pairedItem: { item: index }\n  };\n}\n  \n  // Mark URL as processed\n  staticData.processedUrls[firstUrl] = Date.now();\n  \n  // Clean old entries (older than 24 hours)\n  const dayAgo = Date.now() - 86400000;\n  Object.keys(staticData.processedUrls).forEach(url => {\n    if (staticData.processedUrls[url] < dayAgo) {\n      delete staticData.processedUrls[url];\n    }\n  });\n  \n  return {\n    json: {\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user,\n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -66640,
        -22432
      ],
      "id": "d0ea7ac4-1635-4c44-9cc4-584c19a2de28",
      "name": "Extract Slack URL",
      "executeOnce": false
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -65360,
        -22448
      ],
      "id": "33337fef-da3c-4e18-a909-8cf008d8fa6d",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -65616,
        -22448
      ],
      "id": "68dfb7b4-b700-4c8a-90c6-fa822286d608",
      "name": "Return Slack Challenge"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced HTML Extract - Better for news sites\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconst url = inputData.url || \"\";\n\nconsole.log(\"URL:\", url);\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html || html.length < 100) {\n  console.log(\"No HTML content found\");\n  return [{ \n    json: {\n      error: \"No HTML content received from website\",\n      url: url\n    }\n  }];\n}\n\nconst MAX_LENGTH = 200000;\nlet text = \"\";\n\n// --- YNET SPECIFIC: Try structured data first ---\nconsole.log(\"Trying JSON-LD structured data\");\ntry {\n  const jsonLdMatch = html.match(/<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i);\n  if (jsonLdMatch) {\n    const jsonData = JSON.parse(jsonLdMatch[1]);\n    if (jsonData.articleBody) {\n      text = jsonData.articleBody;\n      console.log(\"✅ Found content in JSON-LD\");\n    }\n  }\n} catch (e) {\n  console.log(\"JSON-LD extraction failed:\", e.message);\n}\n\n// --- Try meta description for headline context ---\nlet metaDescription = \"\";\ntry {\n  const metaMatch = html.match(/<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)[\"']/i) ||\n                    html.match(/<meta[^>]*content=[\"']([^\"']+)[\"'][^>]*name=[\"']description[\"']/i);\n  if (metaMatch) {\n    metaDescription = metaMatch[1];\n  }\n} catch (e) {}\n\n// --- Step 1: Try <article> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <article> tag\");\n  try {\n    const articleMatch = html.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n    if (articleMatch) {\n      text = articleMatch[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, \"\")\n        .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*comment[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (text.length > 500) {\n        console.log(\"✅ Found content in <article>\");\n      } else {\n        text = \"\";\n      }\n    }\n  } catch (e) {\n    console.log(\"Article tag error:\", e.message);\n  }\n}\n\n// --- Step 2: Try <main> tag ---\nif (text.length < 500) {\n  console.log(\"Trying <main> tag\");\n  const mainMatch = html.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n  if (mainMatch) {\n    const extracted = mainMatch[1]\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n      .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n      .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n      .replace(/<div[^>]*class=\"[^\"]*ad[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n      .replace(/<[^>]+>/g, \" \")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    if (extracted.length > text.length) {\n      text = extracted;\n      console.log(\"✅ Found content in <main>\");\n    }\n  }\n}\n\n// --- Step 3: Try common Israeli news site patterns ---\nif (text.length < 500) {\n  console.log(\"Trying Israeli news site patterns\");\n  const contentPatterns = [\n    // Ynet specific\n    /<div[^>]*class=\"[^\"]*art_body[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*article_text[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*class=\"[^\"]*text_block[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    // Generic patterns\n    /<div[^>]*class=\"[^\"]*(?:article-body|post-content|entry-content|main-content|article-content|article__content|post-body|content-body|story-body)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i,\n    /<div[^>]*id=\"[^\"]*(?:article|content|main|post|story)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i\n  ];\n  \n  for (const pattern of contentPatterns) {\n    const match = html.match(pattern);\n    if (match) {\n      const extracted = match[1]\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n        .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n        .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n        .replace(/<div[^>]*class=\"[^\"]*(?:ad|banner|social|share|comment)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi, \"\")\n        .replace(/<[^>]+>/g, \" \")\n        .replace(/\\s+/g, \" \")\n        .trim();\n      \n      if (extracted.length > text.length && extracted.length > 500) {\n        text = extracted;\n        console.log(\"✅ Found content in news site pattern\");\n        break;\n      }\n    }\n  }\n}\n\n// --- Step 4: Aggressive paragraph extraction ---\nif (text.length < 500) {\n  console.log(\"Trying aggressive paragraph extraction\");\n  try {\n    // Get all paragraphs\n    const matches = html.match(/<p[^>]*>(.*?)<\\/p>/gis);\n    if (matches && matches.length > 5) {\n      const paragraphs = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => {\n          const lowerText = t.toLowerCase();\n          return t.length > 50 && \n                 !lowerText.includes('cookie') &&\n                 !lowerText.includes('פרטיות') &&\n                 !lowerText.includes('privacy') &&\n                 !lowerText.includes('תנאי שימוש') &&\n                 !lowerText.includes('הרשמה') &&\n                 !lowerText.includes('subscribe') &&\n                 !lowerText.includes('newsletter');\n        });\n      \n      if (paragraphs.length >= 5) {\n        // Add meta description as headline if available\n        text = (metaDescription ? metaDescription + \"\\n\\n\" : \"\") + paragraphs.join(\"\\n\\n\");\n        console.log(\"✅ Found content in paragraphs\");\n      }\n    }\n  } catch (e) {\n    console.log(\"Paragraph extraction error:\", e.message);\n  }\n}\n\n// --- Step 5: Check for JavaScript-rendered content indicators ---\nif (text.length < 500) {\n  console.log(\"⚠️ Checking for JS-heavy site indicators\");\n  \n  const jsIndicators = [\n    'window.__INITIAL_STATE__',\n    'window.__PRELOADED_STATE__',\n    'data-react-root',\n    'id=\"__next\"',\n    'id=\"root\"',\n    /__NUXT__/,\n    /window\\.__APOLLO_STATE__/\n  ];\n  \n  const hasJsIndicators = jsIndicators.some(indicator => {\n    if (typeof indicator === 'string') {\n      return html.includes(indicator);\n    }\n    return indicator.test(html);\n  });\n  \n  if (hasJsIndicators) {\n    return [{ \n      json: {\n        error: \"This site uses heavy JavaScript rendering. Content cannot be extracted without a browser.\",\n        url: url,\n        suggestion: \"Try sharing a direct link to the article text or PDF version\"\n      }\n    }];\n  }\n}\n\n// --- Step 6: Clean extracted text ---\nif (text.length > 0) {\n  text = text\n    // Remove author bios\n    .replace(/is a (writer|journalist|author|reporter|editor).*?(\\.|$)/gi, \"\")\n    .replace(/writes? (about|for|on).*?(\\.|$)/gi, \"\")\n    .replace(/based in.*?(\\.|$)/gi, \"\")\n    .replace(/כתב(?:ת)? ב.*?(\\.|$)/gi, \"\")\n    // Remove common footer/header text\n    .replace(/all rights reserved/gi, \"\")\n    .replace(/כל הזכויות שמורות/gi, \"\")\n    .replace(/copyright \\d{4}/gi, \"\")\n    .replace(/©\\s*\\d{4}/gi, \"\")\n    // Remove social media prompts\n    .replace(/follow us on.*/gi, \"\")\n    .replace(/עקבו אחרינו.*/gi, \"\")\n    // Clean whitespace\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\n// --- Final validation ---\nif (!text || text.length < 300) {\n  console.log(\"❌ Article body not found or too short\");\n  \n  // Provide specific error message\n  let errorDetail = \"Could not extract article text. \";\n  \n  if (html.includes('נדרשת הרשמה') || html.includes('subscription required')) {\n    errorDetail += \"Site requires subscription or login.\";\n  } else if (html.length < 5000) {\n    errorDetail += \"Page content too small - might be blocked or redirected.\";\n  } else {\n    errorDetail += \"Site may use JavaScript rendering or paywall.\";\n  }\n  \n  return [{ \n    json: {\n      error: errorDetail,\n      url: url,\n      htmlLength: html.length,\n      extractedLength: text.length\n    }\n  }];\n}\n\nconsole.log(`✅ Successfully extracted ${text.length} characters`);\nconsole.log(\"Sample:\", text.slice(0, 300));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn [{ \n  json: {\n    article: text, \n    url: url,\n    originalLength: html.length, \n    extractedLength: text.length \n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -66704,
        -22112
      ],
      "id": "fa398ca8-bcb2-4ab5-ac5c-987fa18bd404",
      "name": "HTML Extract"
    },
    {
      "parameters": {
        "jsCode": "// === HELPER FUNCTION - AT TOP ===\nfunction cleanBullets(bullets, language = \"en\") {\n  return bullets\n    .map(b => {\n      let cleaned = String(b).trim();\n      \n      // Remove workflow text\n      cleaned = cleaned.replace(/\\*Automated with this n8n workflow\\*/gi, \"\");\n      cleaned = cleaned.replace(/Automated with this n8n workflow/gi, \"\");\n      \n      // Remove ALL bullets/dashes from start\n      cleaned = cleaned.replace(/^[•\\-\\s]+/g, \"\").trim();\n      \n      // Fix multiple periods\n      cleaned = cleaned.replace(/\\.{2,}/g, \".\");\n      \n      // Fix period-bullet patterns\n      cleaned = cleaned.replace(/\\.\\s*•+\\s*/g, \". \");\n      \n      // Remove duplicate spaces\n      cleaned = cleaned.replace(/\\s{2,}/g, \" \");\n      \n      // Remove quotes\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, \"\");\n      \n      return cleaned.trim();\n    })\n    .filter(b => b && b.length > 20); // Filter short/empty bullets\n}\n\n// Log input\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\n// Get language from input\nconst language = $json.language || \"en\";\nconsole.log(\"Language in Validator:\", language);\n\n// Aggressive cleaning\nlet s = raw\n  .replace(/```json\\s*/gi, \"\")\n  .replace(/```\\s*/g, \"\")\n  .replace(/\\*Automated with.*$/gim, \"\")\n  .replace(/^[^{]*/, \"\")  // Remove before {\n  .replace(/[^}]*$/, \"\")  // Remove after }\n  .replace(/-/g, \"-\")\n  .replace(/[\\r\\n]+/g, \" \")\n  .replace(/[\\u2018\\u2019]/g, \"'\")\n  .replace(/[\\u201C\\u201D]/g, '\"')\n  .replace(/\\s+/g, \" \")\n  .trim();\n\nconsole.log(\"Cleaned string:\", s.slice(0, 300));\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n}\n\n// Try regex salvage if parse failed\nif (!obj || typeof obj !== \"object\") {\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n  \n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)]\n      .map(m => m[1])\n      .filter(b => b.length > 10);\n    \n    return [{\n      json: {\n        title,\n        bullets: cleanBullets(bullets, language),\n        url: $json.url || null,\n        language: language,  // ✅ PASS LANGUAGE\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null,\n      language: language  // ✅ PASS LANGUAGE\n    }\n  }];\n}\n\n// Normal success path\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\n// Clean bullets\nbullets = cleanBullets(bullets, language);\n\n// Ensure exactly 5 bullets\nif (bullets.length > 5) bullets = bullets.slice(0, 5);\n\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים.\" \n  : \"No further details available.\";\n\nwhile (bullets.length < 5) {\n  bullets.push(defaultBullet);\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,\n    url: $json.url || null,\n    language: language,  // ✅ PASS LANGUAGE\n    source: $json.source || \"Local\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64256,
        -22096
      ],
      "id": "82f9572e-575b-488e-86af-921c5a4f8825",
      "name": "Validator"
    },
    {
      "parameters": {
        "jsCode": "const { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// --- Error case ---\nif (error) {\n  const errorMsg = language === \"he\" ? \"שגיאה בעיבוד המאמר\" : \"Error processing article\";\n  const sourceText = language === \"he\" ? \"מקור:\" : \"Source:\";\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${sourceText} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : \"Unknown\")}`\n    }\n  }];\n}\n\n// --- Clean title ---\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .replace(/automated with this n8n workflow/i, \"\")\n  .replace(/\\*Automated with.*$/i, \"\")\n  .replace(/^תקציר[:\\s]+/i, \"\")\n  .replace(/^סיכום[:\\s]+/i, \"\")\n  .replace(/^summary[:\\s]+/i, \"\")\n  .trim();\n\n// --- Clean bullets ---\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => {\n    if (language === \"he\" && (\n      b === \"No further details available.\" || \n      b === \"No further details available\"\n    )) {\n      return false;\n    }\n    return b && b.length > 25;\n  })\n  .map(b => {\n    let cleaned = b\n      .replace(/^[\"']|[\"']$/g, \"\")\n      .replace(/automated with this n8n workflow/i, \"\")\n      .replace(/\\*Automated with.*$/i, \"\")\n      .replace(/^[•\\-\\s]+/, \"\")\n      .replace(/\\.{2,}/g, \".\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n    \n    return cleaned;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\nconst defaultBullet = language === \"he\" \n  ? \"לא נמצאו פרטים נוספים בנושא זה\" \n  : \"No further details available\";\n\nwhile (cleanBullets.length < 5) {\n  cleanBullets.push(defaultBullet);\n}\n\n// --- Track metrics ---\nconst metrics = $getWorkflowStaticData('global').metrics || { total: 0, success: 0 };\nmetrics.total++;\nmetrics.success++;\n$getWorkflowStaticData('global').metrics = metrics;\nconsole.log(`Success rate: ${(metrics.success/metrics.total*100).toFixed(1)}%`);\n\n// --- Build Slack message ---\nconst RLM = \"\\u200F\"; // Right-to-Left Mark\nconst LRM = \"\\u200E\"; // Left-to-Right Mark\n\nif (language === \"he\") {\n  // Improved regex to wrap English, numbers, and special characters\n  function wrapEnglish(text) {\n    // Match English words, numbers with decimals/commas, and mixed content\n    return text.replace(/([A-Za-z0-9]+(?:[.,:/\\-][A-Za-z0-9]+)*)/g, `${LRM}$1${LRM}`);\n  }\n  \n  const wrappedTitle = wrapEnglish(cleanTitle);\n  \n  // Hebrew: NO \"סיכום:\" prefix, just emoji + title\n  const titleLine = url \n    ? `${RLM}:brain: <${url}|${wrappedTitle}>` \n    : `${RLM}:brain: ${wrappedTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => {\n    const wrappedBullet = wrapEnglish(b);\n    return `${RLM}• ${wrappedBullet}`;\n  });\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n  \n} else {\n  // English: Keep \"Summary:\" prefix\n  const titleLine = url \n    ? `:brain: Summary: <${url}|${cleanTitle}>` \n    : `:brain: Summary: ${cleanTitle}`;\n  \n  const bulletLines = cleanBullets.map(b => `• ${b}`);\n  \n  return [{ \n    json: { \n      text: [titleLine, \"\", ...bulletLines, \"\"].join(\"\\n\")\n    } \n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64000,
        -22096
      ],
      "id": "9d9f0861-7c99-4bd4-933f-278b2874e04a",
      "name": "Formatter"
    },
    {
      "parameters": {
        "url": "={{$json.fetchUrl}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -66928,
        -22112
      ],
      "id": "9455bb97-07b9-4735-be04-20d086c28215",
      "name": "HTTP Request",
      "retryOnFail": false,
      "executeOnce": false,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert summarization tool that creates accurate, fact-based summaries.\n\nLanguage: {{$json[\"language\"]}}\n\nCRITICAL: You MUST summarize in the language specified by the \"Language\" parameter above.\n- If language is \"he\" → summarize in Hebrew\n- If language is \"en\" → summarize in English (EVEN IF the source text is in Russian, Cyrillic, or another language)\n\nThe source text may be in Hebrew, English, Russian, or other languages, but you MUST write your summary in the language specified above.\n\nTASK: Summarize the text into exactly 5 detailed bullet points IN THE LANGUAGE SPECIFIED ABOVE.\n\nACCURACY RULES:\n- ONLY use information explicitly stated in the source text\n- NEVER invent, assume, or add names, facts, or details not in the source\n- Use names and facts exactly as written in the source\n- Do NOT add context or background not present in the text\n\nBULLET REQUIREMENTS:\n- Each bullet: 3-5 complete sentences (40-60 words)\n- Start each bullet with • (bullet character)\n- Include only specific information from the source\n- Write in clear, journalistic style\n- Every sentence must be complete\n\nOUTPUT RULES:\n- Output ONLY valid JSON\n- NO markdown (no ```), NO extra text\n- Start with { and end with }\n\nRequired format:\n{\"title\":\"Title in the language specified above\",\"bullets\":[\"• First detailed bullet.\",\"• Second detailed bullet.\",\"• Third detailed bullet.\",\"• Fourth detailed bullet.\",\"• Fifth detailed bullet.\"]}\n\nText to summarize:\n{{ $json[\"chunk\"] }}\n\nCRITICAL: Write the summary in {{$json[\"language\"]}} language. If the parameter is \"en\", write in English. If \"he\", write in Hebrew.",
        "needsFallback": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -65056,
        -22096
      ],
      "id": "34ca356c-530a-434d-bc6f-d4fe1f6f1b48",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -66880,
        -22432
      ],
      "id": "3e66a8cf-0cd3-40ee-9779-962d9e8840df",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"Chunker input article length:\", $json.article?.length || 0, \"Sample:\", $json.article?.slice(0, 500));\n\nconst CHUNK_SIZE = 5000;   // smaller than before\nconst OVERLAP = 150;\nconst MAX_CHUNKS = 10;\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ json: { url, chunk: text.slice(i, i + CHUNK_SIZE), index: chunks.length + 1 } });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Sample chunk:\", chunks[0]?.json.chunk.slice(0, 500));\nreturn chunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -65808,
        -22096
      ],
      "id": "5e498db8-fa13-49c3-a2c0-f6311d007068",
      "name": "Chunker",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64544,
        -22096
      ],
      "id": "67f69db1-b9b7-4500-8309-52267a73facb",
      "name": "Debug logger",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// LANGUAGE DETECTOR NODE\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",  // Default fallback\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count Hebrew characters\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\n\n// Count Cyrillic characters (Russian)\nconst cyrillicMatches = text.match(/[\\u0400-\\u04FF]/g) || [];\nconst cyrillicChars = cyrillicMatches.length;\n\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\nconst cyrillicRatio = cyrillicChars / totalChars;\n\n// Detect language - treat Russian as English for summarization\nlet language = \"en\";\nif (hebrewRatio > 0.2 && totalChars > 200) {\n  language = \"he\";\n} else if (cyrillicRatio > 0.2 && totalChars > 200) {\n  language = \"en\";  // Russian articles will be summarized in English\n}\n\nconsole.log(`Language detected: ${language}, Hebrew: ${hebrewChars}, Cyrillic: ${cyrillicChars}, Total: ${totalChars}`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -65552,
        -22096
      ],
      "id": "27b1cbdd-524c-4c44-90bd-714cd8d86c38",
      "name": "Language Detector"
    },
    {
      "parameters": {
        "jsCode": "// Format Error Message - FIXED\nconst error = $json.error || \"Unknown error\";\nconst url = $json.url || $input.first()?.json?.url || 'Unknown URL';\nconst language = $json.language || 'en';\n\nconsole.log(\"Error formatting - URL:\", url, \"Error:\", error);\n\nconst errorMsg = language === 'he' \n  ? '⚠️ נכשל בסיכום המאמר'\n  : '⚠️ Failed to summarize article';\n\nconst detailMsg = language === 'he'\n  ? `סיבה: ${error}`\n  : `Reason: ${error}`;\n\nconst sourceText = language === 'he' ? 'מקור:' : 'Source:';\n\nreturn [{\n  json: {\n    text: `${errorMsg}\\n${detailMsg}\\n\\n${sourceText} <${url}|${url}>`\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64912,
        -22432
      ],
      "id": "25536def-e8e7-4ede-87fe-0b3830cc8867",
      "name": "Format Error Message"
    },
    {
      "parameters": {
        "amount": 2
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -65344,
        -22096
      ],
      "id": "3bcc3aff-11af-4174-8da2-3d42fc2eb65f",
      "name": "Wait",
      "webhookId": "10236448-b9ab-466e-b2f5-cbe1633592d1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -66304,
        -22432
      ],
      "id": "21b6f324-5afa-4aba-ad6a-77ec10d66718",
      "name": "Check URL Verification"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a8b1824d-7f4a-44b2-9117-e9ffce906f69",
              "leftValue": "={{ $json.isDuplicate }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -66480,
        -22768
      ],
      "id": "a5337a05-576d-489d-99ce-1290a8e834e1",
      "name": "Check Duplicate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "5e3db3e5-dc18-47c5-9c94-1086878f8f31",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -66480,
        -22112
      ],
      "id": "6d2bab09-b54b-450e-8104-ca5e845a21f6",
      "name": "Check Extract Error"
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {
          "includeLinkToWorkflow": "={{ false }}"
        }
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -64192,
        -22784
      ],
      "id": "40e6849b-6546-4357-8efe-a52e415168f6",
      "name": "Send Summary",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -65280,
        -22784
      ],
      "id": "0d45cc79-1579-4a54-a47b-2e1d76d9e337",
      "name": "Send Duplicate Notice",
      "webhookId": "214e8692-2d7d-4ade-9ec1-77708747f604",
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "google/gemma-3-12b",
          "mode": "list",
          "cachedResultName": "google/gemma-3-12b"
        },
        "options": {
          "maxTokens": 1500,
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -65120,
        -21824
      ],
      "id": "879a71c2-d1a5-4fe6-96b3-6513cfc7d39a",
      "name": "Gemma 3 12B",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    },
    {
      "parameters": {
        "model": "openai/gpt-5-nano",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -64944,
        -21824
      ],
      "id": "c1c35a36-9bca-4297-b4c7-3e354ddba388",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "hGAnvpSAhWRbFktq",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pre-fetch URL Checker\nconst url = $json.url;\n\n// Check if URL is from known problematic sites\nconst problematicSites = {\n  'ynet.co.il': 'mobile',\n  'mako.co.il': 'mobile',\n  'walla.co.il': 'mobile'\n};\n\nlet strategy = 'desktop';\ntry {\n  const domain = new URL(url).hostname;\n  for (const [site, strat] of Object.entries(problematicSites)) {\n    if (domain.includes(site)) {\n      strategy = strat;\n      console.log(`Using ${strategy} strategy for ${domain}`);\n      break;\n    }\n  }\n} catch (e) {}\n\n// For mobile strategy, try to convert URL to mobile version\nlet fetchUrl = url;\nif (strategy === 'mobile' && url.includes('ynet.co.il')) {\n  // Some sites have mobile versions that are easier to parse\n  fetchUrl = url.replace('www.ynet', 'm.ynet');\n}\n\nreturn [{\n  json: {\n    url: url,\n    fetchUrl: fetchUrl,\n    strategy: strategy\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -67232,
        -22112
      ],
      "id": "2770eeee-efc3-4d4c-a54d-ed0118c5996d",
      "name": "Code in JavaScript"
    }
  ],
  "connections": {
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "Check Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "Check Extract Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Debug logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Language Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Error Message": {
      "main": [
        [
          {
            "node": "Send Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check URL Verification": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicate": {
      "main": [
        [
          {
            "node": "Send Duplicate Notice",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check URL Verification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Extract Error": {
      "main": [
        [
          {
            "node": "Format Error Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemma 3 12B": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Asia/Jerusalem",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": {
    "global": {
      "metrics": {
        "total": 45,
        "success": 45
      },
      "processedUrls": {
        "https://www.engadget.com/computing/windows-10-support-ends-october-14-but-heres-how-to-get-an-extra-year-for-free-125118616.html": 1760201049881,
        "https://www.tgspot.co.il/sora-app-ios-million-downloads/?fbclid=IwZnRzaANYlvxleHRuA2FlbQIxMQABHitXvjej9zevQJgIe_hxC0lFd9vUqOnC8ghfbvbCl-s7Y2R7mdDovI_-GQFF_aem_G27AhUtuCugcV8gP0O7Bbw": 1760278463395
      },
      "processedEvents": {
        "Ev09KMRSSM08": 1759655642156
      }
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "7a494b95-173d-46a1-bf42-c86a063d5b4c",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-09-02T14:14:42.897Z",
      "updatedAt": "2025-09-02T14:14:42.897Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "NptNxIUgBjUJaRfd"
    }
  ],
  "tags": []
}