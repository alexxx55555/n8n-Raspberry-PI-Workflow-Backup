{
  "updatedAt": "2026-02-17T20:26:02.733Z",
  "createdAt": "2025-11-15T11:13:05.206Z",
  "id": "d9VfLDIb89RxTA8s",
  "name": "Smart Email & Calendar Reminders - Optimized",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "4f90baad-f42a-4d24-acdf-e9a71818fad9",
      "name": "Check Every 15 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1936,
        -7216
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "filters": {
          "q": "newer_than:24h ((\"deadline\" OR \"due date\" OR \"due by\") OR (\"meeting at\" OR \"meeting on\") OR (\"urgent:\" OR \"action required\") OR (\"reminder:\" OR \"don't forget\") OR (\"payment due\" OR \"invoice due\") OR (\"submit by\" OR \"expires on\") OR (\"×ª×–×›×•×¨×ª\" OR \"×“×—×•×£\" OR \"×ª××¨×™×š ×™×¢×“\" OR \"×¤×’×™×©×”\"))"
        }
      },
      "id": "4fa0fb78-6251-4502-841d-db2d8531ad38",
      "name": "Gmail - Fetch Task Emails",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1536,
        -7408
      ],
      "webhookId": "13ab3a69-3954-424a-8100-b474fcc5b6a6",
      "credentials": {
        "gmailOAuth2": {
          "id": "C5742Grqr9Rpnxid",
          "name": "Gmail account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "sashavi55555@gmail.com",
          "mode": "list"
        },
        "limit": 20,
        "options": {
          "orderBy": "startTime"
        }
      },
      "id": "dfc940fd-5439-47e5-82ae-5a5eb46ce71d",
      "name": "Google Calendar - Next 3 Hours",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -1536,
        -7008
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "ceazxv6ZgDLso5CX",
          "name": "Google Calendar account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const CONFIG = {\n  timezone: 'Asia/Jerusalem',\n  reminderWindowDays: 7,\n  maxPreviewLength: 250,\n  urgencyKeywords: {\n    critical: ['urgent', 'asap', 'immediately', 'critical', 'emergency', 'overdue', 'expired', '×“×—×•×£', '××™×™×“×™'],\n    high: ['deadline', 'due', 'must', 'required', 'payment', 'expires', 'invoice', '×ª××¨×™×š ×™×¢×“', '×ª×©×œ×•×', '×—×©×‘×•× ×™×ª'],\n    medium: ['meeting', 'call', 'reminder', 'review', 'submit', 'approval', '×¤×’×™×©×”', '×ª×–×›×•×¨×ª', '××™×©×•×¨'],\n    low: ['fyi', 'update', 'info', 'notice', 'newsletter', '×¢×“×›×•×Ÿ']\n  }\n};\n\nconst out = [];\nconst now = Date.now();\nconst stats = { processed: 0, sent: 0, skipped: 0, errors: 0 };\n\nconst items = $input.all();\nif (items.length === 1 && items[0].json?.error) {\n  return [{ json: { source: 'email', error: true, errorMessage: items[0].json.error } }];\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.emailReminders) staticData.emailReminders = {};\nconst sentEmails = staticData.emailReminders;\n\nconst cutoff = now - (CONFIG.reminderWindowDays * 86400000);\nfor (const [id, ts] of Object.entries(sentEmails)) {\n  if (ts < cutoff) delete sentEmails[id];\n}\n\nfunction extractDates(text) {\n  const dates = [];\n  const patterns = [\n    /\\b(\\d{1,2})[\\/-](\\d{1,2})[\\/-](\\d{2,4})\\b/g,\n    /\\b(\\d{4})[\\/-](\\d{1,2})[\\/-](\\d{1,2})\\b/g,\n    /\\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+(\\d{1,2}),?\\s+(\\d{4})?/gi,\n    /\\b(\\d{1,2})\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*,?\\s+(\\d{4})?/gi,\n    /\\b(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/gi\n  ];\n  for (const p of patterns) {\n    for (const m of text.matchAll(p)) dates.push(m[0]);\n  }\n  return [...new Set(dates)];\n}\n\nfunction getUrgency(text, dates) {\n  const lower = text.toLowerCase();\n  if (CONFIG.urgencyKeywords.critical.some(w => lower.includes(w)))\n    return { emoji: 'ğŸ”´', label: 'CRITICAL', priority: 4 };\n  for (const d of dates) {\n    const parsed = Date.parse(d);\n    if (!isNaN(parsed)) {\n      const days = (parsed - now) / 86400000;\n      if (days >= 0 && days < 1) return { emoji: 'ğŸ”´', label: 'TODAY', priority: 4 };\n      if (days < 2) return { emoji: 'ğŸŸ¡', label: 'TOMORROW', priority: 3 };\n    }\n  }\n  if (CONFIG.urgencyKeywords.high.some(w => lower.includes(w)))\n    return { emoji: 'ğŸ”´', label: 'HIGH', priority: 3 };\n  if (CONFIG.urgencyKeywords.medium.some(w => lower.includes(w)))\n    return { emoji: 'ğŸŸ¡', label: 'MEDIUM', priority: 2 };\n  if (CONFIG.urgencyKeywords.low.some(w => lower.includes(w)))\n    return { emoji: 'ğŸŸ¢', label: 'LOW', priority: 1 };\n  return { emoji: 'âšª', label: 'INFO', priority: 0 };\n}\n\nfunction getSender(item) {\n  let from = item.json.from || item.json.From || '';\n  if ((!from || !from.includes('@')) && item.json.payload?.headers) {\n    const h = item.json.payload.headers.find(h => h.name?.toLowerCase() === 'from');\n    if (h?.value) from = h.value;\n  }\n  const nameMatch = from.match(/^([^<]+)\\s*</);\n  const emailMatch = from.match(/<([^>]+)>/);\n  return {\n    name: nameMatch ? nameMatch[1].trim() : 'Unknown',\n    email: emailMatch ? emailMatch[1].trim() : (from.includes('@') ? from.trim() : 'unknown')\n  };\n}\n\nfunction esc(text) {\n  return (text || '').replace(/([\\[\\]_*`~])/g, '\\\\$1');\n}\n\nfor (const item of items) {\n  try {\n    stats.processed++;\n    const emailId = item.json.id || '';\n    if (sentEmails[emailId] && (now - sentEmails[emailId]) < CONFIG.reminderWindowDays * 86400000) {\n      stats.skipped++;\n      continue;\n    }\n    const subjectRaw = item.json.subject || 'No Subject';\n    const snippet = item.json.snippet || '';\n    const fullText = `${subjectRaw} ${snippet}`;\n    const sender = getSender(item);\n    const dates = extractDates(fullText);\n    const urgency = getUrgency(fullText, dates);\n    if (urgency.priority < 2 && dates.length === 0) { stats.skipped++; continue; }\n\n    let eventDate = null, daysUntil = null;\n    for (const d of dates) {\n      const parsed = Date.parse(d);\n      if (!isNaN(parsed) && parsed > now) {\n        eventDate = new Date(parsed).toLocaleDateString('en-GB', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });\n        daysUntil = Math.ceil((parsed - now) / 86400000);\n        break;\n      }\n    }\n\n    const preview = snippet.length > CONFIG.maxPreviewLength ? snippet.substring(0, CONFIG.maxPreviewLength - 3) + '...' : snippet;\n\n    let msg = `${urgency.emoji} *${urgency.label} - Email*\\n`;\n    msg += `\\nğŸ“§ *Subject:* ${esc(subjectRaw)}\\n`;\n    msg += `ğŸ‘¤ *From:* ${esc(sender.name)} (${esc(sender.email)})\\n`;\n    if (eventDate) {\n      msg += `ğŸ“… *Date:* ${eventDate}`;\n      if (daysUntil !== null) msg += ` (${daysUntil}d)`;\n      msg += `\\n`;\n    }\n    if (dates.length > 1) msg += `ğŸ“Œ *Other dates:* ${dates.slice(1, 3).join(', ')}\\n`;\n    msg += `\\n_${esc(preview)}_\\n`;\n    msg += `\\n[Open in Gmail](https://mail.google.com/mail/u/0/#inbox/${emailId})`;\n\n    sentEmails[emailId] = now;\n    stats.sent++;\n    out.push({ json: { source: 'email', reminderMessage: msg, shouldSendReminder: true, emailId, subject: subjectRaw, priority: urgency.priority, timestamp: now } });\n  } catch (e) {\n    stats.errors++;\n    console.error(`Email error: ${e.message}`);\n  }\n}\n\nconsole.log(`Email: ${stats.processed} processed, ${stats.sent} sent, ${stats.skipped} skipped, ${stats.errors} errors`);\nreturn out.length > 0 ? out : [{ json: { shouldSendReminder: false, source: 'email' } }];"
      },
      "id": "75aca78c-de2a-4b75-b336-58b772837951",
      "name": "Format Email Reminders",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1232,
        -7408
      ]
    },
    {
      "parameters": {
        "jsCode": "const CONFIG = {\n  timezone: 'Asia/Jerusalem',\n  deduplicationHours: 24,\n  reminderWindows: [\n    { max: 180, min: 61, label: '~2 hours' },\n    { max: 60, min: 31, label: '1 hour' },\n    { max: 30, min: 16, label: '30 minutes' },\n    { max: 15, min: 6, label: '15 minutes' },\n    { max: 5, min: 0, label: 'Starting NOW' }\n  ]\n};\n\nconst out = [];\nconst now = Date.now();\nconst stats = { processed: 0, sent: 0, skipped: 0, errors: 0 };\n\nconst items = $input.all();\nif (items.length === 1 && items[0].json?.error) {\n  return [{ json: { source: 'calendar', error: true, errorMessage: items[0].json.error } }];\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.calendarEvents) staticData.calendarEvents = {};\nconst sent = staticData.calendarEvents;\n\nconst cutoff = now - (CONFIG.deduplicationHours * 3600000);\nfor (const [k, ts] of Object.entries(sent)) {\n  if (ts < cutoff) delete sent[k];\n}\n\nfunction getWindow(mins) {\n  for (const w of CONFIG.reminderWindows) {\n    if (mins <= w.max && mins >= w.min) return w;\n  }\n  return null;\n}\n\nfunction getMeetingInfo(ev) {\n  if (ev.hangoutLink) return { hasVideo: true, platform: 'Google Meet', link: ev.hangoutLink };\n  const loc = (ev.location || '').toLowerCase();\n  if (loc.includes('zoom')) return { hasVideo: true, platform: 'Zoom', link: ev.location.match(/https?:\\/\\/[^\\s]+zoom[^\\s]+/i)?.[0] || ev.location };\n  if (loc.includes('teams.microsoft')) return { hasVideo: true, platform: 'Teams', link: ev.location.match(/https?:\\/\\/[^\\s]+teams[^\\s]+/i)?.[0] || ev.location };\n  return { hasVideo: false, platform: null, link: null };\n}\n\nfunction esc(text) {\n  return (text || '').replace(/([\\[\\]_*`~])/g, '\\\\$1');\n}\n\nfor (const item of items) {\n  try {\n    stats.processed++;\n    const ev = item.json;\n    const eventId = ev.id || '';\n    const startISO = ev.start?.dateTime || ev.start?.date;\n    if (!startISO) { stats.skipped++; continue; }\n\n    const startDate = new Date(startISO);\n    const minsUntil = Math.floor((startDate - now) / 60000);\n    if (minsUntil < 0 || minsUntil > 180) { stats.skipped++; continue; }\n\n    const win = getWindow(minsUntil);\n    if (!win) { stats.skipped++; continue; }\n\n    const key = `${eventId}_${win.label}`;\n    if (sent[key]) { stats.skipped++; continue; }\n\n    const meeting = getMeetingInfo(ev);\n    const fmtTime = (iso) => iso ? new Date(iso).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', timeZone: CONFIG.timezone }) : null;\n    const startTime = fmtTime(startISO);\n    const endTime = fmtTime(ev.end?.dateTime || ev.end?.date);\n\n    const attendees = (ev.attendees || [])\n      .filter(a => !a.self && a.responseStatus !== 'declined')\n      .map(a => {\n        const name = a.displayName || a.email?.split('@')[0] || '?';\n        const icon = a.responseStatus === 'accepted' ? 'âœ“' : a.responseStatus === 'tentative' ? '?' : '';\n        return icon ? `${name}${icon}` : name;\n      }).slice(0, 5);\n\n    const urgencyEmoji = minsUntil <= 5 ? 'ğŸ”´' : minsUntil <= 15 ? 'ğŸŸ ' : minsUntil <= 30 ? 'ğŸŸ¡' : 'ğŸŸ¢';\n    const priority = minsUntil <= 5 ? 5 : minsUntil <= 15 ? 4 : minsUntil <= 30 ? 3 : 2;\n\n    let msg = `${urgencyEmoji} *${win.label} - Calendar*\\n`;\n    msg += `\\nğŸ“… *${esc(ev.summary || 'Untitled Event')}*\\n`;\n    msg += `ğŸ•’ ${startTime}${endTime ? ' - ' + endTime : ''} (in ${minsUntil}min)\\n`;\n    if (ev.organizer && !ev.organizer.self) msg += `ğŸ‘” ${esc(ev.organizer.displayName || ev.organizer.email?.split('@')[0])}\\n`;\n    if (attendees.length > 0) {\n      msg += `ğŸ‘¥ ${attendees.join(', ')}`;\n      if ((ev.attendees || []).length > 5) msg += ` +${ev.attendees.length - 5}`;\n      msg += `\\n`;\n    }\n    if (!meeting.hasVideo && ev.location) msg += `ğŸ“ ${esc(ev.location)}\\n`;\n    if (meeting.hasVideo) msg += `\\nğŸ¥ [Join ${meeting.platform}](${meeting.link})\\n`;\n    if (ev.htmlLink) msg += `[View in Calendar](${ev.htmlLink})`;\n\n    sent[key] = now;\n    stats.sent++;\n    out.push({ json: { source: 'calendar', reminderMessage: msg, shouldSendReminder: true, eventId, priority, timestamp: now } });\n  } catch (e) {\n    stats.errors++;\n    console.error(`Calendar error: ${e.message}`);\n  }\n}\n\nconsole.log(`Calendar: ${stats.processed} processed, ${stats.sent} sent, ${stats.skipped} skipped, ${stats.errors} errors`);\nreturn out.length > 0 ? out : [{ json: { shouldSendReminder: false, source: 'calendar' } }];"
      },
      "id": "faca8a93-937e-4518-ad23-b23c8d761e6e",
      "name": "Format Calendar Reminders",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1232,
        -7008
      ]
    },
    {
      "parameters": {},
      "id": "b4f9200d-e833-48f8-a23d-c47215772651",
      "name": "Merge All Reminders",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -928,
        -7216
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "25d0b2a6-83c3-4721-a71a-42432fa0d505",
              "leftValue": "={{ $json.shouldSendReminder }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "9eb6fd03-6d72-457f-b808-ff75d6ff7444",
      "name": "Filter Valid Reminders",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.1,
      "position": [
        -624,
        -7216
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nitems.sort((a, b) => (b.json.priority || 0) - (a.json.priority || 0));\nconst MAX_PER_RUN = 5;\nif (items.length > MAX_PER_RUN) {\n  console.log(`Rate limiting: ${items.length} reminders, sending top ${MAX_PER_RUN}`);\n  return items.slice(0, MAX_PER_RUN);\n}\nreturn items;"
      },
      "id": "863940f1-c709-4840-af9c-2dee136ffb74",
      "name": "Sort & Rate Limit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        -7216
      ]
    },
    {
      "parameters": {
        "chatId": "426570413",
        "text": "={{ $json.reminderMessage }}",
        "additionalFields": {
          "disable_web_page_preview": true,
          "parse_mode": "Markdown"
        }
      },
      "id": "7d2ab423-fab6-4d99-aabd-ed7f231c8d72",
      "name": "Send Telegram Notification",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        32,
        -7216
      ],
      "webhookId": "754cc178-2afb-4bef-92cf-c2d0bfb2c9ef",
      "credentials": {
        "telegramApi": {
          "id": "WlROsIRML0DIjcRe",
          "name": "email_task_bot"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.deliveryLog) staticData.deliveryLog = [];\nif (!staticData.failedQueue) staticData.failedQueue = [];\nif (!staticData.dailyStats) staticData.dailyStats = { date: '', sent: 0, failed: 0, retried: 0 };\n\nconst now = Date.now();\nconst todayStr = new Date(now).toISOString().slice(0, 10);\nconst result = $json;\nconst originalMsg = $('Sort & Rate Limit').item.json;\nconst success = !result.error && result.message_id;\n\n// Reset daily stats at midnight\nif (staticData.dailyStats.date !== todayStr) {\n  staticData.yesterdayStats = { ...staticData.dailyStats };\n  staticData.dailyStats = { date: todayStr, sent: 0, failed: 0, retried: 0 };\n}\n\n// Log delivery\nstaticData.deliveryLog.push({ timestamp: now, success, source: originalMsg.source, subject: originalMsg.subject || originalMsg.eventId || 'unknown' });\nif (staticData.deliveryLog.length > 100) staticData.deliveryLog = staticData.deliveryLog.slice(-100);\n\nconst outputs = [];\n\nif (success) {\n  staticData.dailyStats.sent++;\n} else {\n  staticData.dailyStats.failed++;\n  staticData.failedQueue.push({\n    message: originalMsg.reminderMessage,\n    source: originalMsg.source,\n    attempt: 1,\n    maxAttempts: 3,\n    queuedAt: now,\n    lastError: JSON.stringify(result).substring(0, 200)\n  });\n  console.error('Send failed, queued for retry');\n}\n\n// Process retry queue\nconst stillWaiting = [];\nfor (const item of staticData.failedQueue) {\n  const waitMs = item.attempt * 60000;\n  if (now - item.queuedAt >= waitMs && item.attempt <= item.maxAttempts) {\n    item.attempt++;\n    item.queuedAt = now;\n    staticData.dailyStats.retried++;\n    outputs.push({ json: { reminderMessage: 'ğŸ”„ *Retry (attempt ' + item.attempt + '/' + item.maxAttempts + ')*\\n\\n' + item.message, isRetry: true } });\n    if (item.attempt <= item.maxAttempts) stillWaiting.push(item);\n  } else if (item.attempt <= item.maxAttempts) {\n    stillWaiting.push(item);\n  } else {\n    console.error('Permanently failed after ' + item.maxAttempts + ' attempts: ' + item.source);\n  }\n}\nstaticData.failedQueue = stillWaiting;\n\n// Daily summary at ~8 AM Israel time\nconst israelHour = parseInt(new Date(now).toLocaleString('en-GB', { hour: 'numeric', hour12: false, timeZone: 'Asia/Jerusalem' }));\nif (israelHour === 8 && staticData.yesterdayStats?.date) {\n  if (!staticData.dailySummarySent) staticData.dailySummarySent = {};\n  if (!staticData.dailySummarySent[todayStr]) {\n    const ys = staticData.yesterdayStats;\n    if (ys.sent > 0 || ys.failed > 0) {\n      const rate = ys.sent + ys.failed > 0 ? Math.round((ys.sent / (ys.sent + ys.failed)) * 100) : 100;\n      let summary = 'ğŸ“Š *Daily Reminder Summary*\\n';\n      summary += '\\nâœ… Sent: ' + ys.sent;\n      summary += '\\nâŒ Failed: ' + ys.failed;\n      if (ys.retried > 0) summary += '\\nğŸ”„ Retried: ' + ys.retried;\n      summary += '\\nğŸ“ˆ Success rate: ' + rate + '%';\n      if (ys.failed > 0) {\n        const fails = staticData.deliveryLog.filter(l => !l.success).slice(-3).map(l => '  â€¢ ' + l.source + ': ' + l.subject).join('\\n');\n        if (fails) summary += '\\n\\nâš ï¸ *Recent failures:*\\n' + fails;\n      }\n      outputs.push({ json: { reminderMessage: summary, isDailySummary: true } });\n      staticData.dailySummarySent[todayStr] = true;\n    }\n  }\n  // Clean old flags\n  for (const d of Object.keys(staticData.dailySummarySent || {})) {\n    if (d < new Date(now - 259200000).toISOString().slice(0, 10)) delete staticData.dailySummarySent[d];\n  }\n}\n\n// Clean old failed queue items\nstaticData.failedQueue = staticData.failedQueue.filter(i => now - i.queuedAt < 86400000);\n\nreturn outputs.length > 0 ? outputs : [{ json: { delivered: success, noAction: true } }];"
      },
      "id": "529777db-1349-47a6-83dd-268e2572639e",
      "name": "Track & Retry & Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        336,
        -7216
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "a1b2c3d4-filter-retry",
              "leftValue": "={{ $json.reminderMessage }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ff6cb6db-f345-48a3-9699-ff2e69650309",
      "name": "Has Retry or Summary?",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.1,
      "position": [
        624,
        -7216
      ]
    },
    {
      "parameters": {
        "chatId": "426570413",
        "text": "={{ $json.reminderMessage }}",
        "additionalFields": {
          "disable_web_page_preview": true,
          "parse_mode": "Markdown"
        }
      },
      "id": "c89786ea-2c01-4a77-bd20-f33b6740cb60",
      "name": "Send Retry or Summary",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        912,
        -7216
      ],
      "webhookId": "aec91e63-632a-4dc4-9908-a31e529c1192",
      "credentials": {
        "telegramApi": {
          "id": "WlROsIRML0DIjcRe",
          "name": "email_task_bot"
        }
      },
      "continueOnFail": true
    }
  ],
  "connections": {
    "Check Every 15 Minutes": {
      "main": [
        [
          {
            "node": "Gmail - Fetch Task Emails",
            "type": "main",
            "index": 0
          },
          {
            "node": "Google Calendar - Next 3 Hours",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gmail - Fetch Task Emails": {
      "main": [
        [
          {
            "node": "Format Email Reminders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Calendar - Next 3 Hours": {
      "main": [
        [
          {
            "node": "Format Calendar Reminders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Email Reminders": {
      "main": [
        [
          {
            "node": "Merge All Reminders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Calendar Reminders": {
      "main": [
        [
          {
            "node": "Merge All Reminders",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge All Reminders": {
      "main": [
        [
          {
            "node": "Filter Valid Reminders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Valid Reminders": {
      "main": [
        [
          {
            "node": "Sort & Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort & Rate Limit": {
      "main": [
        [
          {
            "node": "Send Telegram Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Telegram Notification": {
      "main": [
        [
          {
            "node": "Track & Retry & Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Track & Retry & Summary": {
      "main": [
        [
          {
            "node": "Has Retry or Summary?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Retry or Summary?": {
      "main": [
        [
          {
            "node": "Send Retry or Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Asia/Jerusalem",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Check Every Hour": {
      "recurrenceRules": []
    },
    "node:Check Every Hour1": {
      "recurrenceRules": []
    },
    "node:Check Every 30 Minutes1": {
      "recurrenceRules": []
    },
    "node:Check Every 1 Hour": {
      "recurrenceRules": []
    },
    "node:Check Every 1 Hour1": {
      "recurrenceRules": []
    },
    "global": {
      "emailReminders": {
        "19c6cc2d9837e724": 1771360210884,
        "19c6c39204d42b3b": 1771360210884,
        "19c71cc101ec217f": 1771435810382,
        "19c71ca3e16f8833": 1771435810382,
        "19c71c866a04365f": 1771435810382,
        "19c71c69484a5c8a": 1771435810382,
        "19c71e90d11b6b1a": 1771438508838,
        "19c7465820f15d0d": 1771479914640,
        "19c7464f447dc83e": 1771479914640
      },
      "calendarEvents": {
        "69i38oj374pj8b9k74om2b9k6or30b9p71i34bb474pm6phiclhmcd9h64_30": 1767884401866,
        "ckp36oj6cdj64b9hcopmab9k6dgm2b9p6dj3cb9hcos3ip9hclh34d9m6g_120": 1767927601029,
        "ckp36oj6cdj64b9hcopmab9k6dgm2b9p6dj3cb9hcos3ip9hclh34d9m6g_60": 1767931201643,
        "6go3ee1h71i62b9p6li3gb9kc8q68bb2clim4bb2cgq30dhi61ij4ob6cc_20260109T120000Z_120": 1767952801460,
        "6go3ee1h71i62b9p6li3gb9kc8q68bb2clim4bb2cgq30dhi61ij4ob6cc_20260109T120000Z_60": 1767956401132
      },
      "sentItems": {},
      "recentReminders": [],
      "sentHashes": {
        "2f308c17": 1767870051248,
        "77a6536d": 1767873651300,
        "4daedce0": 1767884401889,
        "4c22c8f": 1767927601043,
        "58898f6f": 1767931201657,
        "4b13f30e": 1767952801472,
        "3d9f8480": 1767956401143
      },
      "deliveryLog": [
        {
          "timestamp": 1771360212522,
          "source": "email",
          "subject": "No Subject"
        },
        {
          "timestamp": 1771435813220,
          "source": "email",
          "subject": "No Subject"
        },
        {
          "timestamp": 1771438509594,
          "source": "email",
          "subject": "No Subject"
        },
        {
          "timestamp": 1771479915652,
          "source": "email",
          "subject": "No Subject"
        }
      ],
      "failedQueue": [
        {
          "message": "ğŸ”´ *CRITICAL - Email*\n\nğŸ“§ *Subject:* No Subject\nğŸ‘¤ *From:* Unknown (sashavi55555@gmail.com)\n\n_ğŸ” Password Expiry Alert Report Generated: 2/18/2026, 5:28:44 PM Total Expiring 2 Critical (â‰¤3 days) 2 Already Expired 2 User Password Status Username Full Name Email Status Expiry Date irinad Irina_\n\n[Open in Gmail](https://mail.google.com/mail/u/0/#inbox/19c71cc101ec217f)",
          "source": "email",
          "attempt": 3,
          "maxAttempts": 3,
          "queuedAt": 1771479915652,
          "lastError": "{\"ok\":true,\"result\":{\"message_id\":301,\"from\":{\"id\":7979559172,\"is_bot\":true,\"first_name\":\"EmailTaskBot\",\"username\":\"email_task_bot\"},\"chat\":{\"id\":426570413,\"first_name\":\"Alex\",\"last_name\":\"Vi\",\"userna"
        },
        {
          "message": "ğŸ”´ *CRITICAL - Email*\n\nğŸ“§ *Subject:* No Subject\nğŸ‘¤ *From:* Unknown (sashavi55555@gmail.com)\n\n_ğŸ” Password Expiry Alert Report Generated: 2/18/2026, 6:00:24 PM Total Expiring 2 Critical (â‰¤3 days) 2 Already Expired 2 User Password Status Username Full Name Email Status Expiry Date irinad Irina_\n\n[Open in Gmail](https://mail.google.com/mail/u/0/#inbox/19c71e90d11b6b1a)",
          "source": "email",
          "attempt": 2,
          "maxAttempts": 3,
          "queuedAt": 1771479915652,
          "lastError": "{\"ok\":true,\"result\":{\"message_id\":305,\"from\":{\"id\":7979559172,\"is_bot\":true,\"first_name\":\"EmailTaskBot\",\"username\":\"email_task_bot\"},\"chat\":{\"id\":426570413,\"first_name\":\"Alex\",\"last_name\":\"Vi\",\"userna"
        },
        {
          "message": "ğŸ”´ *CRITICAL - Email*\n\nğŸ“§ *Subject:* No Subject\nğŸ‘¤ *From:* Unknown (sashavi55555@gmail.com)\n\n_ğŸ” Password Expiry Alert Report Generated: 2/19/2026, 5:35:35 AM Total Expiring 2 Critical (â‰¤3 days) 2 Already Expired 2 User Password Status Username Full Name Email Status Expiry Date irinad Irina_\n\n[Open in Gmail](https://mail.google.com/mail/u/0/#inbox/19c7465820f15d0d)",
          "source": "email",
          "attempt": 1,
          "maxAttempts": 3,
          "queuedAt": 1771479915652,
          "lastError": "{\"ok\":true,\"result\":{\"message_id\":306,\"from\":{\"id\":7979559172,\"is_bot\":true,\"first_name\":\"EmailTaskBot\",\"username\":\"email_task_bot\"},\"chat\":{\"id\":426570413,\"first_name\":\"Alex\",\"last_name\":\"Vi\",\"userna"
        }
      ],
      "dailyStats": {
        "date": "2026-02-19",
        "sent": 0,
        "failed": 1,
        "retried": 3
      },
      "yesterdayStats": {
        "date": "2026-02-18",
        "sent": 0,
        "failed": 2,
        "retried": 3
      }
    },
    "node:Check Every 15 Minutes": {
      "recurrenceRules": []
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "2f216629-ba77-4c78-8ab0-552763daeb8a",
  "activeVersionId": "2f216629-ba77-4c78-8ab0-552763daeb8a",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-11-15T11:13:05.213Z",
      "createdAt": "2025-11-15T11:13:05.213Z",
      "role": "workflow:owner",
      "workflowId": "d9VfLDIb89RxTA8s",
      "projectId": "pWTWmuHnmIHw48U9"
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-17T20:26:05.000Z",
    "createdAt": "2026-02-17T20:26:02.737Z",
    "versionId": "2f216629-ba77-4c78-8ab0-552763daeb8a",
    "workflowId": "d9VfLDIb89RxTA8s",
    "nodes": [
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "minutes",
                "minutesInterval": 15
              }
            ]
          }
        },
        "id": "4f90baad-f42a-4d24-acdf-e9a71818fad9",
        "name": "Check Every 15 Minutes",
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.2,
        "position": [
          -1936,
          -7216
        ]
      },
      {
        "parameters": {
          "operation": "getAll",
          "filters": {
            "q": "newer_than:24h ((\"deadline\" OR \"due date\" OR \"due by\") OR (\"meeting at\" OR \"meeting on\") OR (\"urgent:\" OR \"action required\") OR (\"reminder:\" OR \"don't forget\") OR (\"payment due\" OR \"invoice due\") OR (\"submit by\" OR \"expires on\") OR (\"×ª×–×›×•×¨×ª\" OR \"×“×—×•×£\" OR \"×ª××¨×™×š ×™×¢×“\" OR \"×¤×’×™×©×”\"))"
          }
        },
        "id": "4fa0fb78-6251-4502-841d-db2d8531ad38",
        "name": "Gmail - Fetch Task Emails",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          -1536,
          -7408
        ],
        "webhookId": "13ab3a69-3954-424a-8100-b474fcc5b6a6",
        "credentials": {
          "gmailOAuth2": {
            "id": "C5742Grqr9Rpnxid",
            "name": "Gmail account"
          }
        },
        "continueOnFail": true
      },
      {
        "parameters": {
          "operation": "getAll",
          "calendar": {
            "__rl": true,
            "value": "sashavi55555@gmail.com",
            "mode": "list"
          },
          "limit": 20,
          "options": {
            "orderBy": "startTime"
          }
        },
        "id": "dfc940fd-5439-47e5-82ae-5a5eb46ce71d",
        "name": "Google Calendar - Next 3 Hours",
        "type": "n8n-nodes-base.googleCalendar",
        "typeVersion": 1.3,
        "position": [
          -1536,
          -7008
        ],
        "credentials": {
          "googleCalendarOAuth2Api": {
            "id": "ceazxv6ZgDLso5CX",
            "name": "Google Calendar account"
          }
        },
        "continueOnFail": true
      },
      {
        "parameters": {
          "jsCode": "const CONFIG = {\n  timezone: 'Asia/Jerusalem',\n  reminderWindowDays: 7,\n  maxPreviewLength: 250,\n  urgencyKeywords: {\n    critical: ['urgent', 'asap', 'immediately', 'critical', 'emergency', 'overdue', 'expired', '×“×—×•×£', '××™×™×“×™'],\n    high: ['deadline', 'due', 'must', 'required', 'payment', 'expires', 'invoice', '×ª××¨×™×š ×™×¢×“', '×ª×©×œ×•×', '×—×©×‘×•× ×™×ª'],\n    medium: ['meeting', 'call', 'reminder', 'review', 'submit', 'approval', '×¤×’×™×©×”', '×ª×–×›×•×¨×ª', '××™×©×•×¨'],\n    low: ['fyi', 'update', 'info', 'notice', 'newsletter', '×¢×“×›×•×Ÿ']\n  }\n};\n\nconst out = [];\nconst now = Date.now();\nconst stats = { processed: 0, sent: 0, skipped: 0, errors: 0 };\n\nconst items = $input.all();\nif (items.length === 1 && items[0].json?.error) {\n  return [{ json: { source: 'email', error: true, errorMessage: items[0].json.error } }];\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.emailReminders) staticData.emailReminders = {};\nconst sentEmails = staticData.emailReminders;\n\nconst cutoff = now - (CONFIG.reminderWindowDays * 86400000);\nfor (const [id, ts] of Object.entries(sentEmails)) {\n  if (ts < cutoff) delete sentEmails[id];\n}\n\nfunction extractDates(text) {\n  const dates = [];\n  const patterns = [\n    /\\b(\\d{1,2})[\\/-](\\d{1,2})[\\/-](\\d{2,4})\\b/g,\n    /\\b(\\d{4})[\\/-](\\d{1,2})[\\/-](\\d{1,2})\\b/g,\n    /\\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+(\\d{1,2}),?\\s+(\\d{4})?/gi,\n    /\\b(\\d{1,2})\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*,?\\s+(\\d{4})?/gi,\n    /\\b(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/gi\n  ];\n  for (const p of patterns) {\n    for (const m of text.matchAll(p)) dates.push(m[0]);\n  }\n  return [...new Set(dates)];\n}\n\nfunction getUrgency(text, dates) {\n  const lower = text.toLowerCase();\n  if (CONFIG.urgencyKeywords.critical.some(w => lower.includes(w)))\n    return { emoji: 'ğŸ”´', label: 'CRITICAL', priority: 4 };\n  for (const d of dates) {\n    const parsed = Date.parse(d);\n    if (!isNaN(parsed)) {\n      const days = (parsed - now) / 86400000;\n      if (days >= 0 && days < 1) return { emoji: 'ğŸ”´', label: 'TODAY', priority: 4 };\n      if (days < 2) return { emoji: 'ğŸŸ¡', label: 'TOMORROW', priority: 3 };\n    }\n  }\n  if (CONFIG.urgencyKeywords.high.some(w => lower.includes(w)))\n    return { emoji: 'ğŸ”´', label: 'HIGH', priority: 3 };\n  if (CONFIG.urgencyKeywords.medium.some(w => lower.includes(w)))\n    return { emoji: 'ğŸŸ¡', label: 'MEDIUM', priority: 2 };\n  if (CONFIG.urgencyKeywords.low.some(w => lower.includes(w)))\n    return { emoji: 'ğŸŸ¢', label: 'LOW', priority: 1 };\n  return { emoji: 'âšª', label: 'INFO', priority: 0 };\n}\n\nfunction getSender(item) {\n  let from = item.json.from || item.json.From || '';\n  if ((!from || !from.includes('@')) && item.json.payload?.headers) {\n    const h = item.json.payload.headers.find(h => h.name?.toLowerCase() === 'from');\n    if (h?.value) from = h.value;\n  }\n  const nameMatch = from.match(/^([^<]+)\\s*</);\n  const emailMatch = from.match(/<([^>]+)>/);\n  return {\n    name: nameMatch ? nameMatch[1].trim() : 'Unknown',\n    email: emailMatch ? emailMatch[1].trim() : (from.includes('@') ? from.trim() : 'unknown')\n  };\n}\n\nfunction esc(text) {\n  return (text || '').replace(/([\\[\\]_*`~])/g, '\\\\$1');\n}\n\nfor (const item of items) {\n  try {\n    stats.processed++;\n    const emailId = item.json.id || '';\n    if (sentEmails[emailId] && (now - sentEmails[emailId]) < CONFIG.reminderWindowDays * 86400000) {\n      stats.skipped++;\n      continue;\n    }\n    const subjectRaw = item.json.subject || 'No Subject';\n    const snippet = item.json.snippet || '';\n    const fullText = `${subjectRaw} ${snippet}`;\n    const sender = getSender(item);\n    const dates = extractDates(fullText);\n    const urgency = getUrgency(fullText, dates);\n    if (urgency.priority < 2 && dates.length === 0) { stats.skipped++; continue; }\n\n    let eventDate = null, daysUntil = null;\n    for (const d of dates) {\n      const parsed = Date.parse(d);\n      if (!isNaN(parsed) && parsed > now) {\n        eventDate = new Date(parsed).toLocaleDateString('en-GB', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });\n        daysUntil = Math.ceil((parsed - now) / 86400000);\n        break;\n      }\n    }\n\n    const preview = snippet.length > CONFIG.maxPreviewLength ? snippet.substring(0, CONFIG.maxPreviewLength - 3) + '...' : snippet;\n\n    let msg = `${urgency.emoji} *${urgency.label} - Email*\\n`;\n    msg += `\\nğŸ“§ *Subject:* ${esc(subjectRaw)}\\n`;\n    msg += `ğŸ‘¤ *From:* ${esc(sender.name)} (${esc(sender.email)})\\n`;\n    if (eventDate) {\n      msg += `ğŸ“… *Date:* ${eventDate}`;\n      if (daysUntil !== null) msg += ` (${daysUntil}d)`;\n      msg += `\\n`;\n    }\n    if (dates.length > 1) msg += `ğŸ“Œ *Other dates:* ${dates.slice(1, 3).join(', ')}\\n`;\n    msg += `\\n_${esc(preview)}_\\n`;\n    msg += `\\n[Open in Gmail](https://mail.google.com/mail/u/0/#inbox/${emailId})`;\n\n    sentEmails[emailId] = now;\n    stats.sent++;\n    out.push({ json: { source: 'email', reminderMessage: msg, shouldSendReminder: true, emailId, subject: subjectRaw, priority: urgency.priority, timestamp: now } });\n  } catch (e) {\n    stats.errors++;\n    console.error(`Email error: ${e.message}`);\n  }\n}\n\nconsole.log(`Email: ${stats.processed} processed, ${stats.sent} sent, ${stats.skipped} skipped, ${stats.errors} errors`);\nreturn out.length > 0 ? out : [{ json: { shouldSendReminder: false, source: 'email' } }];"
        },
        "id": "75aca78c-de2a-4b75-b336-58b772837951",
        "name": "Format Email Reminders",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1232,
          -7408
        ]
      },
      {
        "parameters": {
          "jsCode": "const CONFIG = {\n  timezone: 'Asia/Jerusalem',\n  deduplicationHours: 24,\n  reminderWindows: [\n    { max: 180, min: 61, label: '~2 hours' },\n    { max: 60, min: 31, label: '1 hour' },\n    { max: 30, min: 16, label: '30 minutes' },\n    { max: 15, min: 6, label: '15 minutes' },\n    { max: 5, min: 0, label: 'Starting NOW' }\n  ]\n};\n\nconst out = [];\nconst now = Date.now();\nconst stats = { processed: 0, sent: 0, skipped: 0, errors: 0 };\n\nconst items = $input.all();\nif (items.length === 1 && items[0].json?.error) {\n  return [{ json: { source: 'calendar', error: true, errorMessage: items[0].json.error } }];\n}\n\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.calendarEvents) staticData.calendarEvents = {};\nconst sent = staticData.calendarEvents;\n\nconst cutoff = now - (CONFIG.deduplicationHours * 3600000);\nfor (const [k, ts] of Object.entries(sent)) {\n  if (ts < cutoff) delete sent[k];\n}\n\nfunction getWindow(mins) {\n  for (const w of CONFIG.reminderWindows) {\n    if (mins <= w.max && mins >= w.min) return w;\n  }\n  return null;\n}\n\nfunction getMeetingInfo(ev) {\n  if (ev.hangoutLink) return { hasVideo: true, platform: 'Google Meet', link: ev.hangoutLink };\n  const loc = (ev.location || '').toLowerCase();\n  if (loc.includes('zoom')) return { hasVideo: true, platform: 'Zoom', link: ev.location.match(/https?:\\/\\/[^\\s]+zoom[^\\s]+/i)?.[0] || ev.location };\n  if (loc.includes('teams.microsoft')) return { hasVideo: true, platform: 'Teams', link: ev.location.match(/https?:\\/\\/[^\\s]+teams[^\\s]+/i)?.[0] || ev.location };\n  return { hasVideo: false, platform: null, link: null };\n}\n\nfunction esc(text) {\n  return (text || '').replace(/([\\[\\]_*`~])/g, '\\\\$1');\n}\n\nfor (const item of items) {\n  try {\n    stats.processed++;\n    const ev = item.json;\n    const eventId = ev.id || '';\n    const startISO = ev.start?.dateTime || ev.start?.date;\n    if (!startISO) { stats.skipped++; continue; }\n\n    const startDate = new Date(startISO);\n    const minsUntil = Math.floor((startDate - now) / 60000);\n    if (minsUntil < 0 || minsUntil > 180) { stats.skipped++; continue; }\n\n    const win = getWindow(minsUntil);\n    if (!win) { stats.skipped++; continue; }\n\n    const key = `${eventId}_${win.label}`;\n    if (sent[key]) { stats.skipped++; continue; }\n\n    const meeting = getMeetingInfo(ev);\n    const fmtTime = (iso) => iso ? new Date(iso).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', timeZone: CONFIG.timezone }) : null;\n    const startTime = fmtTime(startISO);\n    const endTime = fmtTime(ev.end?.dateTime || ev.end?.date);\n\n    const attendees = (ev.attendees || [])\n      .filter(a => !a.self && a.responseStatus !== 'declined')\n      .map(a => {\n        const name = a.displayName || a.email?.split('@')[0] || '?';\n        const icon = a.responseStatus === 'accepted' ? 'âœ“' : a.responseStatus === 'tentative' ? '?' : '';\n        return icon ? `${name}${icon}` : name;\n      }).slice(0, 5);\n\n    const urgencyEmoji = minsUntil <= 5 ? 'ğŸ”´' : minsUntil <= 15 ? 'ğŸŸ ' : minsUntil <= 30 ? 'ğŸŸ¡' : 'ğŸŸ¢';\n    const priority = minsUntil <= 5 ? 5 : minsUntil <= 15 ? 4 : minsUntil <= 30 ? 3 : 2;\n\n    let msg = `${urgencyEmoji} *${win.label} - Calendar*\\n`;\n    msg += `\\nğŸ“… *${esc(ev.summary || 'Untitled Event')}*\\n`;\n    msg += `ğŸ•’ ${startTime}${endTime ? ' - ' + endTime : ''} (in ${minsUntil}min)\\n`;\n    if (ev.organizer && !ev.organizer.self) msg += `ğŸ‘” ${esc(ev.organizer.displayName || ev.organizer.email?.split('@')[0])}\\n`;\n    if (attendees.length > 0) {\n      msg += `ğŸ‘¥ ${attendees.join(', ')}`;\n      if ((ev.attendees || []).length > 5) msg += ` +${ev.attendees.length - 5}`;\n      msg += `\\n`;\n    }\n    if (!meeting.hasVideo && ev.location) msg += `ğŸ“ ${esc(ev.location)}\\n`;\n    if (meeting.hasVideo) msg += `\\nğŸ¥ [Join ${meeting.platform}](${meeting.link})\\n`;\n    if (ev.htmlLink) msg += `[View in Calendar](${ev.htmlLink})`;\n\n    sent[key] = now;\n    stats.sent++;\n    out.push({ json: { source: 'calendar', reminderMessage: msg, shouldSendReminder: true, eventId, priority, timestamp: now } });\n  } catch (e) {\n    stats.errors++;\n    console.error(`Calendar error: ${e.message}`);\n  }\n}\n\nconsole.log(`Calendar: ${stats.processed} processed, ${stats.sent} sent, ${stats.skipped} skipped, ${stats.errors} errors`);\nreturn out.length > 0 ? out : [{ json: { shouldSendReminder: false, source: 'calendar' } }];"
        },
        "id": "faca8a93-937e-4518-ad23-b23c8d761e6e",
        "name": "Format Calendar Reminders",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1232,
          -7008
        ]
      },
      {
        "parameters": {},
        "id": "b4f9200d-e833-48f8-a23d-c47215772651",
        "name": "Merge All Reminders",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2,
        "position": [
          -928,
          -7216
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 1
            },
            "conditions": [
              {
                "id": "25d0b2a6-83c3-4721-a71a-42432fa0d505",
                "leftValue": "={{ $json.shouldSendReminder }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "9eb6fd03-6d72-457f-b808-ff75d6ff7444",
        "name": "Filter Valid Reminders",
        "type": "n8n-nodes-base.filter",
        "typeVersion": 2.1,
        "position": [
          -624,
          -7216
        ]
      },
      {
        "parameters": {
          "jsCode": "const items = $input.all();\nitems.sort((a, b) => (b.json.priority || 0) - (a.json.priority || 0));\nconst MAX_PER_RUN = 5;\nif (items.length > MAX_PER_RUN) {\n  console.log(`Rate limiting: ${items.length} reminders, sending top ${MAX_PER_RUN}`);\n  return items.slice(0, MAX_PER_RUN);\n}\nreturn items;"
        },
        "id": "863940f1-c709-4840-af9c-2dee136ffb74",
        "name": "Sort & Rate Limit",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -272,
          -7216
        ]
      },
      {
        "parameters": {
          "chatId": "426570413",
          "text": "={{ $json.reminderMessage }}",
          "additionalFields": {
            "disable_web_page_preview": true,
            "parse_mode": "Markdown"
          }
        },
        "id": "7d2ab423-fab6-4d99-aabd-ed7f231c8d72",
        "name": "Send Telegram Notification",
        "type": "n8n-nodes-base.telegram",
        "typeVersion": 1.2,
        "position": [
          32,
          -7216
        ],
        "webhookId": "754cc178-2afb-4bef-92cf-c2d0bfb2c9ef",
        "credentials": {
          "telegramApi": {
            "id": "WlROsIRML0DIjcRe",
            "name": "email_task_bot"
          }
        },
        "continueOnFail": true
      },
      {
        "parameters": {
          "jsCode": "const staticData = $getWorkflowStaticData('global');\nif (!staticData.deliveryLog) staticData.deliveryLog = [];\nif (!staticData.failedQueue) staticData.failedQueue = [];\nif (!staticData.dailyStats) staticData.dailyStats = { date: '', sent: 0, failed: 0, retried: 0 };\n\nconst now = Date.now();\nconst todayStr = new Date(now).toISOString().slice(0, 10);\nconst result = $json;\nconst originalMsg = $('Sort & Rate Limit').item.json;\nconst success = !result.error && result.message_id;\n\n// Reset daily stats at midnight\nif (staticData.dailyStats.date !== todayStr) {\n  staticData.yesterdayStats = { ...staticData.dailyStats };\n  staticData.dailyStats = { date: todayStr, sent: 0, failed: 0, retried: 0 };\n}\n\n// Log delivery\nstaticData.deliveryLog.push({ timestamp: now, success, source: originalMsg.source, subject: originalMsg.subject || originalMsg.eventId || 'unknown' });\nif (staticData.deliveryLog.length > 100) staticData.deliveryLog = staticData.deliveryLog.slice(-100);\n\nconst outputs = [];\n\nif (success) {\n  staticData.dailyStats.sent++;\n} else {\n  staticData.dailyStats.failed++;\n  staticData.failedQueue.push({\n    message: originalMsg.reminderMessage,\n    source: originalMsg.source,\n    attempt: 1,\n    maxAttempts: 3,\n    queuedAt: now,\n    lastError: JSON.stringify(result).substring(0, 200)\n  });\n  console.error('Send failed, queued for retry');\n}\n\n// Process retry queue\nconst stillWaiting = [];\nfor (const item of staticData.failedQueue) {\n  const waitMs = item.attempt * 60000;\n  if (now - item.queuedAt >= waitMs && item.attempt <= item.maxAttempts) {\n    item.attempt++;\n    item.queuedAt = now;\n    staticData.dailyStats.retried++;\n    outputs.push({ json: { reminderMessage: 'ğŸ”„ *Retry (attempt ' + item.attempt + '/' + item.maxAttempts + ')*\\n\\n' + item.message, isRetry: true } });\n    if (item.attempt <= item.maxAttempts) stillWaiting.push(item);\n  } else if (item.attempt <= item.maxAttempts) {\n    stillWaiting.push(item);\n  } else {\n    console.error('Permanently failed after ' + item.maxAttempts + ' attempts: ' + item.source);\n  }\n}\nstaticData.failedQueue = stillWaiting;\n\n// Daily summary at ~8 AM Israel time\nconst israelHour = parseInt(new Date(now).toLocaleString('en-GB', { hour: 'numeric', hour12: false, timeZone: 'Asia/Jerusalem' }));\nif (israelHour === 8 && staticData.yesterdayStats?.date) {\n  if (!staticData.dailySummarySent) staticData.dailySummarySent = {};\n  if (!staticData.dailySummarySent[todayStr]) {\n    const ys = staticData.yesterdayStats;\n    if (ys.sent > 0 || ys.failed > 0) {\n      const rate = ys.sent + ys.failed > 0 ? Math.round((ys.sent / (ys.sent + ys.failed)) * 100) : 100;\n      let summary = 'ğŸ“Š *Daily Reminder Summary*\\n';\n      summary += '\\nâœ… Sent: ' + ys.sent;\n      summary += '\\nâŒ Failed: ' + ys.failed;\n      if (ys.retried > 0) summary += '\\nğŸ”„ Retried: ' + ys.retried;\n      summary += '\\nğŸ“ˆ Success rate: ' + rate + '%';\n      if (ys.failed > 0) {\n        const fails = staticData.deliveryLog.filter(l => !l.success).slice(-3).map(l => '  â€¢ ' + l.source + ': ' + l.subject).join('\\n');\n        if (fails) summary += '\\n\\nâš ï¸ *Recent failures:*\\n' + fails;\n      }\n      outputs.push({ json: { reminderMessage: summary, isDailySummary: true } });\n      staticData.dailySummarySent[todayStr] = true;\n    }\n  }\n  // Clean old flags\n  for (const d of Object.keys(staticData.dailySummarySent || {})) {\n    if (d < new Date(now - 259200000).toISOString().slice(0, 10)) delete staticData.dailySummarySent[d];\n  }\n}\n\n// Clean old failed queue items\nstaticData.failedQueue = staticData.failedQueue.filter(i => now - i.queuedAt < 86400000);\n\nreturn outputs.length > 0 ? outputs : [{ json: { delivered: success, noAction: true } }];"
        },
        "id": "529777db-1349-47a6-83dd-268e2572639e",
        "name": "Track & Retry & Summary",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          336,
          -7216
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 1
            },
            "conditions": [
              {
                "id": "a1b2c3d4-filter-retry",
                "leftValue": "={{ $json.reminderMessage }}",
                "rightValue": "",
                "operator": {
                  "type": "string",
                  "operation": "isNotEmpty"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "ff6cb6db-f345-48a3-9699-ff2e69650309",
        "name": "Has Retry or Summary?",
        "type": "n8n-nodes-base.filter",
        "typeVersion": 2.1,
        "position": [
          624,
          -7216
        ]
      },
      {
        "parameters": {
          "chatId": "426570413",
          "text": "={{ $json.reminderMessage }}",
          "additionalFields": {
            "disable_web_page_preview": true,
            "parse_mode": "Markdown"
          }
        },
        "id": "c89786ea-2c01-4a77-bd20-f33b6740cb60",
        "name": "Send Retry or Summary",
        "type": "n8n-nodes-base.telegram",
        "typeVersion": 1.2,
        "position": [
          912,
          -7216
        ],
        "webhookId": "aec91e63-632a-4dc4-9908-a31e529c1192",
        "credentials": {
          "telegramApi": {
            "id": "WlROsIRML0DIjcRe",
            "name": "email_task_bot"
          }
        },
        "continueOnFail": true
      }
    ],
    "connections": {
      "Check Every 15 Minutes": {
        "main": [
          [
            {
              "node": "Gmail - Fetch Task Emails",
              "type": "main",
              "index": 0
            },
            {
              "node": "Google Calendar - Next 3 Hours",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Gmail - Fetch Task Emails": {
        "main": [
          [
            {
              "node": "Format Email Reminders",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Google Calendar - Next 3 Hours": {
        "main": [
          [
            {
              "node": "Format Calendar Reminders",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Email Reminders": {
        "main": [
          [
            {
              "node": "Merge All Reminders",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format Calendar Reminders": {
        "main": [
          [
            {
              "node": "Merge All Reminders",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Merge All Reminders": {
        "main": [
          [
            {
              "node": "Filter Valid Reminders",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Valid Reminders": {
        "main": [
          [
            {
              "node": "Sort & Rate Limit",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Sort & Rate Limit": {
        "main": [
          [
            {
              "node": "Send Telegram Notification",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Telegram Notification": {
        "main": [
          [
            {
              "node": "Track & Retry & Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Track & Retry & Summary": {
        "main": [
          [
            {
              "node": "Has Retry or Summary?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Retry or Summary?": {
        "main": [
          [
            {
              "node": "Send Retry or Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Alex Vinokur",
    "name": "Version 2f216629",
    "description": "",
    "autosaved": true
  },
  "tags": []
}