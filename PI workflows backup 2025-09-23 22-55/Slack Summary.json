{
  "createdAt": "2025-09-02T14:14:42.893Z",
  "updatedAt": "2025-09-23T19:53:43.000Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Slack Summary",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "openai/gpt-oss-20b",
          "mode": "list",
          "cachedResultName": "openai/gpt-oss-20b"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -288,
        464
      ],
      "id": "8bbedf30-7ae6-43af-8b36-114a34927f4b",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "w0UTdzIRbJACBNrx",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        608,
        208
      ],
      "id": "24125beb-2085-4914-80b8-1f1445208063",
      "name": "Send a message",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  const event = body.event || {};\n  const headers = item.json.headers || {};\n\n  // Add debug logging\n  console.log('Received event type:', body.type);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null; // Skip this item\n  }\n\n  // 3) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.subtype === 'bot_message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null; // Skip this item\n  }\n\n  // 4) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null; // Skip this item\n  }\n\n  // 5) Skip messages from your bot (replace with actual bot user ID)\n  const BOT_USER_ID = 'U07K8QJ9XYZ'; // Replace with your bot's user ID\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null; // Skip this item\n  }\n\n  // 6) Extract URLs from message\n  const text = event.text || \"\";\n  const urls = new Set();\n\n  // Slack format: <http://example.com|label> or <http://example.com>\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(text)) !== null) {\n    urls.add(match[1]);\n  }\n\n  // Plain URLs\n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(text)) !== null) {\n    urls.add(match[0]);\n  }\n\n  // Get first valid URL\n  let firstUrl = '';\n  for (const url of urls) {\n    if (url && url.match(/^https?:\\/\\/.+\\..+/)) {\n      firstUrl = url;\n      break;\n    }\n  }\n\n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null; // Skip this item\n  }\n\n  console.log('Found URL:', firstUrl);\n\n  return {\n    json: {\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user,\n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null); // Remove null items (skipped items)"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        -112
      ],
      "id": "d6d94154-ff05-4bd8-9d2a-37fa4ce011ff",
      "name": "Extract Slack URL",
      "executeOnce": false
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        192,
        -128
      ],
      "id": "58bac88e-5435-44b7-9042-24f397049c1c",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -336,
        -112
      ],
      "id": "8cba698a-e5b5-49b8-a8a3-eeacbea8c18c",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        -128
      ],
      "id": "5f11a3b6-91cd-4147-937c-75c4699ef5be",
      "name": "Return Slack Challenge"
    },
    {
      "parameters": {
        "jsCode": "const html = $json[\"data\"] || \"\";\n\n// try to scope to the main <article>, else fall back to whole HTML\nconst scope = (html.match(/<article[\\s\\S]*?<\\/article>/i) || [html])[0];\n\n// capture paragraphs, headings, and list items\nconst matches = scope.match(/<(p|h1|h2|li)[^>]*>(.*?)<\\/\\1>/gis);\n\nlet text = matches\n  ? matches\n      .map(m => m.replace(/<[^>]+>/g, '').trim())\n      .filter(Boolean)\n      .join('\\n\\n')\n  : 'No article content found.';\n\nreturn [{ json: { article: text } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        208
      ],
      "id": "302c3ac4-06d6-40df-b44f-befdd531facb",
      "name": "HTML Extract"
    },
    {
      "parameters": {
        "jsCode": "const source = ($json.source ?? \"Local\").toString();\nconst raw = ($json.text || $json.output || $json.content || \"\").toString();\n\n// ðŸ§¼ ---------- CLEANUP ----------\nlet s = raw\n  .replace(/<think>[\\s\\S]*?<\\/think>/gi, \"\")\n  .replace(/```(?:json)?\\s*([\\s\\S]*?)```/gi, \"$1\")\n  .replace(/^\\s*:warning:.*$/gmi, \"\")\n  .replace(/^\\s*(?:IT Onboarding Bot|APP\\b).*$\\n?/gmi, \"\")\n  .replace(/^\\s*Automated\\s*â€¢.*$/gmi, \"\")\n  .replace(/^\\s*text\\s*$/gmi, \"\")\n  .replace(/^\\s*[{}]\\s*$/gm, \"\")\n  .replace(/,\\s*}/g, \"}\")\n  .replace(/,\\s*]/g, \"]\")\n  .trim();\n\n// ðŸ§ª DEBUG LOG\nconsole.log(\"ðŸ” Cleaned input:\\n\", s);\n\n// ðŸ§  ---------- TRY JSON ----------\nlet obj = null;\ntry { obj = JSON.parse(s); } catch {}\nif (!obj) {\n  const match = s.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    try { obj = JSON.parse(match[0]); } catch {}\n  }\n}\n\n// ðŸ§  ---------- EXTRACT FIELDS ----------\nlet title = \"\";\nlet bullets = [];\n\nif (obj && typeof obj === \"object\") {\n  title = (obj.title || \"\").toString().trim().slice(0, 80);\n  if (Array.isArray(obj.bullets)) {\n    bullets = obj.bullets.map(b => (b ?? \"\").toString().trim()).filter(Boolean);\n  }\n}\n\n// ðŸª‚ ---------- FALLBACK ----------\nif (!title || bullets.length === 0) {\n  const lines = s.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n\n  if (!title) {\n    const tLine = lines.find(l => /^title\\s*[:\\-]\\s*/i.test(l));\n    title = (tLine\n      ? tLine.replace(/^title\\s*[:\\-]\\s*/i, \"\")\n      : lines.find(l => !/^(?:[-*â€¢]|\\d+\\.)\\s+/.test(l)) ||\n        (bullets[0] ? bullets[0].split(/[.!?]\\s/)[0] : \"Summary\")\n    ).toString().trim().slice(0, 80);\n  }\n\n  if (bullets.length === 0) {\n    bullets = lines\n      .filter(l => /^(?:[-*â€¢]|\\d+\\.)\\s+/.test(l))\n      .map(l => l.replace(/^(?:[-*â€¢]|\\d+\\.)\\s+/, \"\").trim())\n      .filter(Boolean);\n\n    // If still no bullets, take long lines as fallback\n    if (bullets.length === 0) {\n      bullets = lines\n        .filter(l => l.length > 30)\n        .slice(0, 5)\n        .map(l => l.replace(/^(?:[-*â€¢]|\\d+\\.)\\s+/, \"\").trim());\n    }\n  }\n}\n\n// ðŸ§¹ ---------- NORMALIZE ----------\nbullets = bullets\n  .map(b => b.replace(/^\\*\\*(.+?)\\*\\*$/, \"$1\").trim())\n  .filter(Boolean)\n  .slice(0, 5);\n\n// ðŸ§¾ ---------- OUTPUT ----------\nif (!title && bullets.length === 0) {\n  return [{\n    json: {\n      error: \"No summary content\",\n      source,\n      raw: s\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    title: title || \"Summary\",\n    bullets,\n    source\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        208
      ],
      "id": "588c795e-b7e6-48d2-ab42-6aaf2c9f214d",
      "name": "Validator"
    },
    {
      "parameters": {
        "jsCode": "const { title, bullets, error, raw, url } = $json;\n\nif (error) {\n  return [{\n    json: {\n      text: `âš ï¸ ${error}\\n\\n\\`\\`\\`\\n${raw?.slice(0, 500) || \"No raw content\"}\\n\\`\\`\\``\n    }\n  }];\n}\n\n// Clean the title\nlet cleanTitle = String(title || \"Summary\")\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=â€“-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .trim();\n\n// Remove footer from title if accidentally included\ncleanTitle = cleanTitle.replace(/automated with this n8n workflow/i, \"\").trim();\n\n// Clean bullets\nconst cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => !/^[\"']?title[\"']?\\s*[:=â€“-]/i.test(b))  // âœ… STRONG title bullet filter\n  .filter(b => !/automated with this n8n workflow/i.test(b))\n  .map(b => {\n    const cleaned = b.replace(/^[\"']|[\"']$/g, \"\").replace(/[.,\"]+$/, \"\").trim();\n    return cleaned.endsWith(\".\") ? cleaned : `${cleaned}.`;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\n// Build final Slack message\nconst parts = [\n  `*ðŸ§  Summary:* ${url ? `<${url}|${cleanTitle}>` : `*${cleanTitle}*`}`,\n  \"\",\n  ...cleanBullets.map(b => `â€¢ ${b}`),\n  \"\"\n];\n\nconst text = parts.join(\"\\n\");\nreturn [{ json: { text } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        304,
        208
      ],
      "id": "cce12e40-f3f3-4a42-904c-4fa613e51a81",
      "name": "Formatter"
    },
    {
      "parameters": {
        "url": "={{$json[\"url\"]}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -960,
        208
      ],
      "id": "016f3ab1-34bc-41d7-9b87-d4624a080bf2",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a summarization tool.\n\nSummarize the following text into exactly 5 meaningful bullet points and a short title.  \nThe article may be incomplete or noisy, but your goal is to extract the most useful or relevant points.\n\nRespond with only a valid JSON object â€” no commentary, code blocks, or <think> tags.\n\nFormat:\n{\n  \"title\": \"A clear headline describing the article (max 80 characters)\",\n  \"bullets\": [\n    \"First meaningful summary point\",\n    \"Second point\",\n    \"Third point\",\n    \"Fourth point\",\n    \"Fifth point\"\n  ]\n}\n\nRules:\n- Only use information from the input text.\n- If content is unclear, keep bullets short but avoid leaving them empty.\n- Never invent facts.\n- If a point is unclear, summarize it in vague but factual terms.\n- Return only the JSON above, with all 5 bullets populated.\n\nText:\n{{ $json[\"article\"] }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -288,
        208
      ],
      "id": "03c3a4e0-ffb9-4ba4-9271-eba9e2131f29",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -912,
        -112
      ],
      "id": "44d27aaf-d7a8-426d-83b0-2182282e9eeb",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    }
  ],
  "connections": {
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "56cd9f56-36d3-4b48-9c15-dfc5dab27e1d",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-09-02T14:14:42.897Z",
      "updatedAt": "2025-09-02T14:14:42.897Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "NptNxIUgBjUJaRfd"
    }
  ],
  "tags": []
}