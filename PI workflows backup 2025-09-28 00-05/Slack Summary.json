{
  "createdAt": "2025-09-02T14:14:42.893Z",
  "updatedAt": "2025-09-27T17:39:56.000Z",
  "id": "GzAlS0kt9q4YI0n7",
  "name": "Slack Summary",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "google/gemma-3-12b",
          "mode": "list",
          "cachedResultName": "google/gemma-3-12b"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1904,
        336
      ],
      "id": "ec524038-6bf1-486a-a622-a4274d8f9e79",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "tPLXnEcJzshXrwfS",
          "name": "Mac-AI"
        }
      }
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C09BFKKCMQ8",
          "mode": "list",
          "cachedResultName": "n8n-sammarize"
        },
        "text": "={{$json[\"text\"]}}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        3424,
        80
      ],
      "id": "4b68e108-909b-49d8-9c13-7e69e2ba4e89",
      "name": "Send a message",
      "webhookId": "babdd094-eea0-4a29-997a-dec4a42ed237",
      "executeOnce": false,
      "credentials": {
        "slackApi": {
          "id": "I5astSkOODZZU76Y",
          "name": "n8n Summery"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process each input item\nreturn items.map((item, index) => {\n  const body = item.json.body || item.json;\n  const event = body.event || {};\n  const headers = item.json.headers || {};\n\n  // Add debug logging\n  console.log('Received event type:', body.type);\n  console.log('Event details:', JSON.stringify(event, null, 2));\n\n  // 1) Handle URL verification challenge\n  if (body.type === 'url_verification') {\n    console.log('URL verification challenge');\n    return {\n      json: { challenge: body.challenge },\n      pairedItem: { item: index }\n    };\n  }\n\n  // 2) Skip Slack retries\n  if (headers['x-slack-retry-num'] || headers['x-slack-retry-reason']) {\n    console.log('Skipping Slack retry');\n    return null; // Skip this item\n  }\n\n  // 3) Skip if not a message event or if it's a bot message\n  if (event.type !== 'message' || event.subtype === 'bot_message' || event.bot_id) {\n    console.log('Not a user message, skipping');\n    return null; // Skip this item\n  }\n\n  // 4) Skip messages without text\n  if (!event.text) {\n    console.log('No text in message');\n    return null; // Skip this item\n  }\n\n  // 5) Skip messages from your bot (replace with actual bot user ID)\n  const BOT_USER_ID = 'U07K8QJ9XYZ'; // Replace with your bot's user ID\n  if (BOT_USER_ID && event.user === BOT_USER_ID) {\n    console.log('Ignoring message from bot');\n    return null; // Skip this item\n  }\n\n  // 6) Extract URLs from message\n  const text = event.text || \"\";\n  const urls = new Set();\n\n  // Slack format: <http://example.com|label> or <http://example.com>\n  const slackUrlRegex = /<(https?:\\/\\/[^>|]+)(\\|[^>]+)?>/g;\n  let match;\n  while ((match = slackUrlRegex.exec(text)) !== null) {\n    urls.add(match[1]);\n  }\n\n  // Plain URLs\n  const plainUrlRegex = /https?:\\/\\/[^\\s<>\"'()[\\]{}]+/g;\n  while ((match = plainUrlRegex.exec(text)) !== null) {\n    urls.add(match[0]);\n  }\n\n  // Get first valid URL\n  let firstUrl = '';\n  for (const url of urls) {\n    if (url && url.match(/^https?:\\/\\/.+\\..+/)) {\n      firstUrl = url;\n      break;\n    }\n  }\n\n  if (!firstUrl) {\n    console.log('No valid URL found in message:', text);\n    return null; // Skip this item\n  }\n\n  console.log('Found URL:', firstUrl);\n\n  return {\n    json: {\n      url: firstUrl,\n      text: text,\n      slack_channel: event.channel,\n      slack_user: event.user,\n      slack_ts: event.ts,\n      slack_thread_ts: event.thread_ts,\n      event_id: body.event_id || `${event.ts}-${Date.now()}`\n    },\n    pairedItem: { item: index }\n  };\n}).filter(item => item !== null); // Remove null items (skipped items)"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1152,
        -240
      ],
      "id": "c9324c93-24be-4d3d-83f0-d3cca27c61b4",
      "name": "Extract Slack URL",
      "executeOnce": false
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        2016,
        -256
      ],
      "id": "cb88f35b-db82-4496-a882-5901250ae375",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0fbb258e-e797-4ea7-ade1-c268ad5ec88c",
              "leftValue": "={{$json[\"body\"][\"type\"]}}",
              "rightValue": "url_verification",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1488,
        -240
      ],
      "id": "d7e3ca70-184b-47e9-abc8-74a81cf6b294",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: { challenge: $json.body.challenge }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        -256
      ],
      "id": "aa9e65aa-3921-4c37-97b7-af11c4fb340a",
      "name": "Return Slack Challenge"
    },
    {
      "parameters": {
        "jsCode": "// Log input for debugging\nconst inputData = $input.first().json;\nconsole.log(\"HTML Extract input fields:\", Object.keys(inputData));\n\nconst html = inputData.data || inputData.html || inputData.body || inputData.content || inputData.response || \"\";\nconsole.log(\"HTML length:\", html.length, \"Sample:\", html.slice(0, 500));\n\nif (!html) {\n  console.log(\"No HTML content found\");\n  return { error: \"No HTML content found\", availableFields: Object.keys(inputData) };\n}\n\nconst MAX_LENGTH = 200000;\nlet matches = null;\nlet text = \"\";\n\n// --- Step 1: Extract from <p> and <h1-h6> ---\ntry {\n  matches = html.match(/<(p|h[1-6])[^>]*>(.*?)<\\/(p|h[1-6])>/gis);\n  if (matches) {\n    text = matches\n      .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n      .filter(t => t.length > 5)\n      .join(\"\\n\\n\");\n  }\n} catch (e) {\n  console.log(\"Regex error (p/h-tags):\", e.message);\n}\n\n// --- Step 2: Fallback to <div>/<span> with article-related classes ---\nif (text.length < 100) {\n  console.log(\"Fallback: checking <div>/<span> for article text\");\n  try {\n    matches = html.match(/<(div|span)[^>]*(article|content|body|text)[^>]*>(.*?)<\\/(div|span)>/gis);\n    if (matches) {\n      text = matches\n        .map(m => m.replace(/<[^>]+>/g, \"\").trim())\n        .filter(t => t.length > 5)\n        .join(\"\\n\\n\");\n    }\n  } catch (e) {\n    console.log(\"Regex error (div/span fallback):\", e.message);\n  }\n}\n\n// --- Step 3: Fallback to embedded JSON (with recursive search) ---\nfunction findArticleText(obj) {\n  if (!obj || typeof obj !== \"object\") return null;\n\n  if (obj.articleBody && typeof obj.articleBody === \"string\") return obj.articleBody;\n  if (obj.text && typeof obj.text === \"string\" && obj.text.length > 100) return obj.text;\n\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      const result = findArticleText(el);\n      if (result) return result;\n    }\n  } else {\n    for (const key of Object.keys(obj)) {\n      const result = findArticleText(obj[key]);\n      if (result) return result;\n    }\n  }\n  return null;\n}\n\nif (text.length < 100) {\n  console.log(\"Fallback: checking for JSON article data\");\n  try {\n    const jsonBlocks = html.match(/<script[^>]+type=[\"']application\\/(ld\\+json|json)[\"'][^>]*>([\\s\\S]*?)<\\/script>/gi);\n    if (jsonBlocks) {\n      for (let block of jsonBlocks) {\n        try {\n          const clean = block.replace(/<script[^>]*>/i, \"\").replace(/<\\/script>/i, \"\").trim();\n          const parsed = JSON.parse(clean);\n          const result = findArticleText(parsed);\n          if (result) {\n            text = result;\n            break;\n          }\n        } catch (err) {\n          console.log(\"JSON parse error in block:\", err.message);\n        }\n      }\n    }\n  } catch (e) {\n    console.log(\"JSON parse fallback error:\", e.message);\n  }\n}\n\n// --- Step 4: Final error handling ---\nif (!text || text.length < 100) {\n  console.log(\"Article body not found (likely JS-rendered or blocked).\");\n  return { \n    error: \"Article body not found (likely JS-rendered or blocked)\", \n    availableFields: Object.keys(inputData),\n    originalLength: html.length,\n    rawSample: html.slice(0, 500)\n  };\n}\n\nconsole.log(\"Extracted text length:\", text.length, \"Sample:\", text.slice(0, 500));\n\nif (text.length > MAX_LENGTH) {\n  text = text.substring(0, MAX_LENGTH) + \"... [truncated]\";\n}\n\nreturn { \n  article: text, \n  originalLength: html.length, \n  extractedLength: text.length \n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        80
      ],
      "id": "7d297b50-2c04-4654-9483-f907ad331e58",
      "name": "HTML Extract"
    },
    {
      "parameters": {
        "jsCode": "// Log input\nconsole.log(\"Validator input:\", JSON.stringify($json, null, 2));\n\nlet raw = $json.output || $json.text || $json.content || \"\";\nif (typeof raw !== \"string\") raw = JSON.stringify(raw);\n\n// Normalize\nlet s = raw\n  .replace(/-/g, \"-\")\n  .replace(/[\\r\\n]+/g, \" \")\n  .replace(/[\\u2018\\u2019]/g, \"'\")\n  .replace(/[\\u201C\\u201D]/g, '\"')\n  .trim();\n\nlet obj = null;\ntry {\n  obj = JSON.parse(s);\n  if (typeof obj === \"string\") obj = JSON.parse(obj);\n} catch (e) {\n  console.log(\"JSON parse failed:\", e.message);\n}\n\n// --- Try regex salvage if parse failed ---\nif (!obj || typeof obj !== \"object\") {\n  const titleMatch = s.match(/\"title\"\\s*:\\s*\"([^\"]+)\"/);\n  const bulletsMatch = s.match(/\"bullets\"\\s*:\\s*\\[([\\s\\S]*?)\\]/);\n\n  if (titleMatch && bulletsMatch) {\n    const title = titleMatch[1];\n    // Safer split: match all quoted strings inside bullets array\n    const bullets = [...bulletsMatch[1].matchAll(/\"([^\"]+)\"/g)].map(m => m[1]);\n\n    return [{\n      json: {\n        title,\n        bullets,\n        url: $json.url || null,\n        source: $json.source || \"Local\"\n      }\n    }];\n  }\n\n  // If still nothing salvageable\n  return [{\n    json: {\n      error: \"Failed to parse AI output into JSON\",\n      raw: s.slice(0, 500),\n      url: $json.url || null\n    }\n  }];\n}\n\n// --- Normal success path ---\nlet title = obj.title || \"Summary\";\nlet bullets = Array.isArray(obj.bullets) ? obj.bullets : [];\n\nif (bullets.length > 5) bullets = bullets.slice(0, 5);\nwhile (bullets.length < 5) {\n  bullets.push(\"No further details available.\");\n}\n\nreturn [{\n  json: {\n    title,\n    bullets,\n    url: $json.url || null,\n    source: $json.source || \"Local\"\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2704,
        80
      ],
      "id": "5854790b-0a71-4da6-8b5a-309136ec0bd3",
      "name": "Validator"
    },
    {
      "parameters": {
        "jsCode": "const { \n  title = \"Summary\", \n  bullets = [], \n  error = null, \n  raw = \"\", \n  url = \"\",\n  language = \"en\"\n} = $json || {};\n\n// --- Error case: show warning in the correct language ---\nif (error) {\n  const errorMsg = language === \"he\" ? \"שגיאה בעיבוד המאמר\" : \"Error processing article\";\n  const sourceText = language === \"he\" ? \"מקור:\" : \"Source:\";\n  \n  return [{\n    json: {\n      text: `⚠️ ${errorMsg}\\n\\n${sourceText} ${url ? `<${url}|${url}>` : (language === \"he\" ? \"לא ידוע\" : \"Unknown\")}\\n\\n\\`\\`\\`\\n${raw?.slice(0, 500) || (language === \"he\" ? \"אין תוכן\" : \"No content\")}\\n\\`\\`\\``\n    }\n  }];\n}\n\n// --- Normal case ---\n\n// Clean title\nlet cleanTitle = String(title)\n  .replace(/^[^{\"]*\"?title[\"']?\\s*[:=–-]\\s*/i, \"\")\n  .replace(/^[\"']|[\"']$/g, \"\")\n  .replace(/[.,\"]+$/, \"\")\n  .trim()\n  .replace(/automated with this n8n workflow/i, \"\")\n  .trim();\n\n// Clean bullets\nlet cleanBullets = (Array.isArray(bullets) ? bullets : [])\n  .map(b => String(b).trim())\n  .filter(b => b && !/^[\"']?title[\"']?\\s*[:=–-]/i.test(b))\n  .filter(b => !/automated with this n8n workflow/i.test(b))\n  .map(b => {\n    const cleaned = b.replace(/^[\"']|[\"']$/g, \"\").replace(/[.,\"]+$/, \"\").trim();\n    const needsPeriod = !/[.!?]$/.test(cleaned) && !/[׃׀]$/.test(cleaned);\n    return needsPeriod ? `${cleaned}.` : cleaned;\n  })\n  .filter(Boolean)\n  .slice(0, 5);\n\n// Guarantee 5 bullets\nconst defaultBullet = language === \"he\" ? \"לא נמצאו פרטים נוספים.\" : \"No further details available.\";\nwhile (cleanBullets.length < 5) {\n  cleanBullets.push(defaultBullet);\n}\n\n// --- Build Slack message ---\n// RTL marker for Hebrew\nconst RTL = \"\\u200F\";\nconst summaryText = language === \"he\" ? \"סיכום:\" : \"Summary:\";\n\nif (language === \"he\") {\n  const parts = [\n    `:brain: ${summaryText} ${url ? `<${url}|${RTL}${cleanTitle}${RTL}>` : RTL + cleanTitle + RTL}`,\n    \"\",\n    ...cleanBullets.map((b, i) => `${i + 1}. ${RTL}${b}${RTL}`),\n    \"\"\n  ];\n  return [{ json: { text: parts.join(\"\\n\") } }];\n} else {\n  const parts = [\n    `:brain: ${summaryText} ${url ? `<${url}|${cleanTitle}>` : cleanTitle}`,\n    \"\",\n    ...cleanBullets.map(b => `• ${b}`),\n    \"\"\n  ];\n  return [{ json: { text: parts.join(\"\\n\") } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2960,
        80
      ],
      "id": "cee4e75d-4d11-4532-b555-cfbaf857624b",
      "name": "Formatter"
    },
    {
      "parameters": {
        "url": "={{$json[\"url\"]}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        864,
        80
      ],
      "id": "59d7b34a-0fd6-4983-b183-b9b2b8cbaa2e",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a summarization tool.\n\nSummarize the following text in {{$json[\"language\"]}}.\n- If \"he\" → write the title and bullets in Hebrew.\n- If \"en\" → write the title and bullets in English.\n\nNever translate — always summarize in the language provided by {{$json[\"language\"]}}.\n\nSummarize into exactly 5 meaningful bullet points and a short title.\n\n⚠️ Important:\n- Output must be ONLY valid JSON (no extra text).\n- Always return 5 bullet points.\n- If the text is unclear or empty, still return JSON with a generic title and 5 short placeholders.\n\nFormat:\n{\n  \"title\": \"Short descriptive title (same language)\",\n  \"bullets\": [\n    \"Bullet point 1\",\n    \"Bullet point 2\",\n    \"Bullet point 3\",\n    \"Bullet point 4\",\n    \"Bullet point 5\"\n  ]\n}\n\nText:\n{{ $json[\"chunk\"] }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1904,
        80
      ],
      "id": "e8cd7869-422b-4e57-84d2-b86495eeedeb",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "slack-events",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        912,
        -240
      ],
      "id": "d2f57135-8ad8-4a19-a70c-4699795d6b4a",
      "name": "Webhook",
      "webhookId": "d63266c1-1b49-4fc1-8530-cbdb5e8fb27f"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"Chunker input article length:\", $json.article?.length || 0, \"Sample:\", $json.article?.slice(0, 500));\n\nconst CHUNK_SIZE = 2000;   // smaller than before\nconst OVERLAP = 150;\nconst MAX_CHUNKS = 20;\n\nconst text = $json.article || \"\";\nconst url = $json.url || \"\";\nconst chunks = [];\n\nfor (let i = 0; i < text.length && chunks.length < MAX_CHUNKS; i += (CHUNK_SIZE - OVERLAP)) {\n  chunks.push({ json: { url, chunk: text.slice(i, i + CHUNK_SIZE), index: chunks.length + 1 } });\n}\n\nconsole.log(\"Generated chunks:\", chunks.length, \"Sample chunk:\", chunks[0]?.json.chunk.slice(0, 500));\nreturn chunks;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        80
      ],
      "id": "081e7e51-1336-4705-b0ce-4ef3ef379dbf",
      "name": "Chunker",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "console.log(\"AI Agent output:\", JSON.stringify($json, null, 2));\nreturn [$json];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2416,
        80
      ],
      "id": "251ddf0a-0212-46f3-ae12-af53acec91c6",
      "name": "Debug logger",
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// LANGUAGE DETECTOR NODE\nconst text = $json.article || $json.chunk || \"\";\nif (!text) {\n  return [{\n    json: { \n      language: \"en\",  // Default fallback\n      chunk: $json.chunk || \"\", \n      url: $json.url || \"\" \n    }\n  }];\n}\n\n// Count Hebrew characters\nconst hebrewMatches = text.match(/[\\u0590-\\u05FF]/g) || [];\nconst hebrewChars = hebrewMatches.length;\nconst totalChars = text.length;\nconst hebrewRatio = hebrewChars / totalChars;\n\n// Only treat as Hebrew if at least 20% of characters are Hebrew AND total length > 200\nconst language = (hebrewRatio > 0.2 && totalChars > 200) ? \"he\" : \"en\";\n\nconsole.log(`Language detected: ${language}, Hebrew chars: ${hebrewChars}, Ratio: ${hebrewRatio.toFixed(3)}, Total: ${totalChars}`);\n\nreturn [{\n  json: {\n    language,\n    chunk: $json.chunk || \"\",\n    url: $json.url || \"\"\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1568,
        80
      ],
      "id": "2caecb92-1314-4c39-9d9a-986c72775c02",
      "name": "Language Detector"
    }
  ],
  "connections": {
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Slack URL": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Return Slack Challenge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Slack Challenge": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Extract": {
      "main": [
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validator": {
      "main": [
        [
          {
            "node": "Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatter": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "HTML Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Debug logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Slack URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Language Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug logger": {
      "main": [
        [
          {
            "node": "Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language Detector": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "ae10beb6-4ebe-4d6b-ab9d-e4a9a8ffd49b",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-09-02T14:14:42.897Z",
      "updatedAt": "2025-09-02T14:14:42.897Z",
      "role": "workflow:owner",
      "workflowId": "GzAlS0kt9q4YI0n7",
      "projectId": "NptNxIUgBjUJaRfd"
    }
  ],
  "tags": []
}